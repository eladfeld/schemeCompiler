;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 51

section .data

const_tbl:
MAKE_VOID

MAKE_NIL

MAKE_LITERAL_BOOL(1)

MAKE_LITERAL_BOOL(0)

MAKE_LITERAL_STRING "whatever"

MAKE_LITERAL_SYMBOL(const_tbl+6)

MAKE_LITERAL_CHAR(0)

MAKE_LITERAL_RATIONAL(0,1)

MAKE_LITERAL_RATIONAL(1,1)

MAKE_LITERAL_RATIONAL(-1,1)

MAKE_LITERAL_STRING "void"

MAKE_LITERAL_SYMBOL(const_tbl+85)

MAKE_LITERAL_RATIONAL(2,1)



;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+4
%define SOB_TRUE_ADDRESS const_tbl+2

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+344], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+208], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+216], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+120], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+16], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+304], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+312], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+352], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+360], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+296], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+288], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+368], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+128], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+376], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+320], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+384], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+224], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+88], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+144], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+152], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+160], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+192], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+200], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+168], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+176], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+184], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+40], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+48], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+32], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+392], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+400], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
mov rax, qword[fvar_tbl+48]
push rax
mov rax, qword[fvar_tbl+40]
push rax
mov rax, qword[fvar_tbl+32]
push rax
mov rax, qword[fvar_tbl+24]
push rax
mov rax, qword[fvar_tbl+16]
push rax
push 5
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode1)
jmp Lcont1
Lcode1:
push rbp
mov rbp, rsp
mov rax,const_tbl+23
push rax
mov rax,const_tbl+23
push rax
push 2
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode2)
jmp Lcont2
Lcode2:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8 * (4 + 0)]
push SOB_NIL_ADDRESS ; something for the cdr
push rax             ; car
push 2               ; argc
push SOB_NIL_ADDRESS ;fake env
call cons
add rsp,8*1          ;pop env
pop rbx              ;pop argc
shl rbx,3            ;rbx=rbx*8
add rsp,rbx          ;pop args
mov qword[rbp + 8 * (4 + 0)],rax
mov qword [rbp + 8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
mov rax, qword[rbp + 8 * (4 + 1)]
push SOB_NIL_ADDRESS ; something for the cdr
push rax             ; car
push 2               ; argc
push SOB_NIL_ADDRESS ;fake env
call cons
add rsp,8*1          ;pop env
pop rbx              ;pop argc
shl rbx,3            ;rbx=rbx*8
add rsp,rbx          ;pop args
mov qword[rbp + 8 * (4 + 1)],rax
mov qword [rbp + 8*(4+1)], rax
mov rax, SOB_VOID_ADDRESS
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode3)
jmp Lcont3
Lcode3:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse4
mov rax,const_tbl+1
jmp Lexit4
Lelse4:
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 2]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 1]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[fvar_tbl+8]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 1]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 4]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
Lexit4:
leave
ret
Lcont3:
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
push SOB_NIL_ADDRESS
call set_car
add rsp, 8              ;pop env
pop rbx                 ;pop argc

shl rbx, 3              ;rbx=rbx*8
add rsp, rbx            ;pop args
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode5)
jmp Lcont5
Lcode5:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse6
mov rax,const_tbl+1
jmp Lexit6
Lelse6:
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 1]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
mov rax, qword[rbp + 8*(4+0)]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
Lexit6:
leave
ret
Lcont5:
push rax
mov rax, qword[rbp + 8*(4+1)]
push rax
push 2
push SOB_NIL_ADDRESS
call set_car
add rsp, 8              ;pop env
pop rbx                 ;pop argc

shl rbx, 3              ;rbx=rbx*8
add rsp, rbx            ;pop args
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode7)
jmp Lcont7
Lcode7:
FIX_STACK_LAMBDA_OPT 2
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont7:
leave
ret
Lcont2:
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont1:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+0], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode8)
jmp Lcont8
Lcode8:
push rbp
mov rbp, rsp
mov rax,const_tbl+1
push rax
mov rax, qword[rbp + 8*(4+2)]
push rax
push 2
mov rax, qword[fvar_tbl+64]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse9
mov rax, qword[rbp + 8*(4+1)]
jmp Lexit9
Lelse9:
mov rax, qword[rbp + 8*(4+2)]
push rax
push 1
mov rax, qword[fvar_tbl+32]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*(4+2)]
push rax
push 1
mov rax, qword[fvar_tbl+24]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*(4+0)]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 3
mov rax, qword[fvar_tbl+56]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 6
CLOSURE_CODE rbx, rax
jmp rbx
Lexit9:
leave
ret
Lcont8:
mov qword[fvar_tbl+56], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode10)
jmp Lcont10
Lcode10:
push rbp
mov rbp, rsp
mov rax,const_tbl+1
push rax
mov rax, qword[rbp + 8*(4+2)]
push rax
push 2
mov rax, qword[fvar_tbl+64]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse11
mov rax, qword[rbp + 8*(4+1)]
jmp Lexit11
Lelse11:
mov rax, qword[rbp + 8*(4+2)]
push rax
push 1
mov rax, qword[fvar_tbl+32]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 3
mov rax, qword[fvar_tbl+72]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+2)]
push rax
push 1
mov rax, qword[fvar_tbl+24]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*(4+0)]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
Lexit11:
leave
ret
Lcont10:
mov qword[fvar_tbl+72], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode12)
jmp Lcont12
Lcode12:
FIX_STACK_LAMBDA_OPT 2
push rbp
mov rbp, rsp
mov rax,const_tbl+1
push rax
mov rax, qword[rbp + 8*(4+1)]
push rax
push 2
mov rax, qword[fvar_tbl+88]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse13
mov rax, qword[rbp + 8*(4+0)]
jmp Lexit13
Lelse13:
mov rax,const_tbl+23
push rax
push 1
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode14)
jmp Lcont14
Lcode14:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8 * (4 + 0)]
push SOB_NIL_ADDRESS ; something for the cdr
push rax             ; car
push 2               ; argc
push SOB_NIL_ADDRESS ;fake env
call cons
add rsp,8*1          ;pop env
pop rbx              ;pop argc
shl rbx,3            ;rbx=rbx*8
add rsp,rbx          ;pop args
mov qword[rbp + 8 * (4 + 0)],rax
mov qword [rbp + 8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode15)
jmp Lcont15
Lcode15:
push rbp
mov rbp, rsp
mov rax,const_tbl+1
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[fvar_tbl+32]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[fvar_tbl+88]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse16
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[fvar_tbl+24]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit16
Lelse16:
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[fvar_tbl+32]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[fvar_tbl+24]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[fvar_tbl+40]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
Lexit16:
leave
ret
Lcont15:
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
push SOB_NIL_ADDRESS
call set_car
add rsp, 8              ;pop env
pop rbx                 ;pop argc

shl rbx, 3              ;rbx=rbx*8
add rsp, rbx            ;pop args
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 1]
push rax
push 1
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 2
mov rax, qword[fvar_tbl+40]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont14:
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
Lexit13:
leave
ret
Lcont12:
mov qword[fvar_tbl+80], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+40]
push rax
mov rax, qword[fvar_tbl+72]
push rax
mov rax, qword[fvar_tbl+16]
push rax
push 3
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode17)
jmp Lcont17
Lcode17:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode18)
jmp Lcont18
Lcode18:
FIX_STACK_LAMBDA_OPT 1
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax,const_tbl+1
push rax
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode19)
jmp Lcont19
Lcode19:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse20
mov rax, qword[rbp + 8*(4+0)]
jmp Lexit20
Lelse20:
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 2]
push rax
push 3
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 6
CLOSURE_CODE rbx, rax
jmp rbx
Lexit20:
leave
ret
Lcont19:
push rax
push 3
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 6
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont18:
leave
ret
Lcont17:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+96], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode21)
jmp Lcont21
Lcode21:
FIX_STACK_LAMBDA_OPT 1
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
leave
ret
Lcont21:
mov qword[fvar_tbl+104], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+32]
push rax
mov rax, qword[fvar_tbl+120]
push rax
mov rax, qword[fvar_tbl+16]
push rax
push 3
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode22)
jmp Lcont22
Lcode22:
push rbp
mov rbp, rsp
mov rax,const_tbl+23
push rax
push 1
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode23)
jmp Lcont23
Lcode23:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode24)
jmp Lcont24
Lcode24:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
jne Lexit25
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse26
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
mov rax, qword[fvar_tbl+112]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit26
Lelse26:
mov rax,const_tbl+4
Lexit26:
cmp rax, SOB_FALSE_ADDRESS
jne Lexit25
Lexit25:
leave
ret
Lcont24:
mov qword [rbp + 8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
mov rax, qword[rbp + 8*(4+0)]
leave
ret
Lcont23:
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont22:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+112], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+128]
push rax
mov rax, qword[fvar_tbl+24]
push rax
mov rax, qword[fvar_tbl+16]
push rax
push 3
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode27)
jmp Lcont27
Lcode27:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode28)
jmp Lcont28
Lcode28:
FIX_STACK_LAMBDA_OPT 2
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse29
mov rax,const_tbl+32
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit29
Lelse29:
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
Lexit29:
leave
ret
Lcont28:
leave
ret
Lcont27:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+128], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode30)
jmp Lcont30
Lcode30:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
cmp rax, SOB_FALSE_ADDRESS
je Lelse31
mov rax,const_tbl+4
jmp Lexit31
Lelse31:
mov rax,const_tbl+2
Lexit31:
leave
ret
Lcont30:
mov qword[fvar_tbl+136], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+16]
push rax
mov rax, qword[fvar_tbl+32]
push rax
mov rax, qword[fvar_tbl+24]
push rax
mov rax, qword[fvar_tbl+200]
push rax
mov rax, qword[fvar_tbl+192]
push rax
mov rax, qword[fvar_tbl+160]
push rax
mov rax, qword[fvar_tbl+152]
push rax
mov rax, qword[fvar_tbl+144]
push rax
mov rax, qword[fvar_tbl+0]
push rax
mov rax, qword[fvar_tbl+56]
push rax
mov rax, qword[fvar_tbl+224]
push rax
mov rax, qword[fvar_tbl+216]
push rax
mov rax, qword[fvar_tbl+208]
push rax
push 13
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode32)
jmp Lcont32
Lcode32:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode33)
jmp Lcont33
Lcode33:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode34)
jmp Lcont34
Lcode34:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse38
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
jmp Lexit38
Lelse38:
mov rax,const_tbl+4
Lexit38:
cmp rax, SOB_FALSE_ADDRESS
je Lelse35
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit35
Lelse35:
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse37
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
jmp Lexit37
Lelse37:
mov rax,const_tbl+4
Lexit37:
cmp rax, SOB_FALSE_ADDRESS
je Lelse36
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit36
Lelse36:
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
Lexit36:
Lexit35:
leave
ret
Lcont34:
leave
ret
Lcont33:
push rax
push 1
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode39)
jmp Lcont39
Lcode39:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode40)
jmp Lcont40
Lcode40:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse41
mov rax, qword[rbp + 8*(4+0)]
jmp Lexit41
Lelse41:
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[fvar_tbl+176]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[fvar_tbl+168]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[fvar_tbl+184]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
MAKE_EXT_ENV 3
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode42)
jmp Lcont42
Lcode42:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1
mov rax, qword[fvar_tbl+176]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 7]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1
mov rax, qword[fvar_tbl+168]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 7]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 7]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont42:
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
Lexit41:
leave
ret
Lcont40:
push rax
push 1
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode43)
jmp Lcont43
Lcode43:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 3
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode44)
jmp Lcont44
Lcode44:
FIX_STACK_LAMBDA_OPT 1
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax,const_tbl+34
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 5]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 3
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont44:
mov qword [fvar_tbl+144],rax
mov rax,SOB_VOID_ADDRESS
MAKE_EXT_ENV 3
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode45)
jmp Lcont45
Lcode45:
FIX_STACK_LAMBDA_OPT 1
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax,const_tbl+51
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 6]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 3
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont45:
mov qword [fvar_tbl+152],rax
mov rax,SOB_VOID_ADDRESS
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 7]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
MAKE_EXT_ENV 3
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode46)
jmp Lcont46
Lcode46:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 4
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode47)
jmp Lcont47
Lcode47:
FIX_STACK_LAMBDA_OPT 2
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 3]
mov rax, qword[rax + 8 * 12]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse48
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax,const_tbl+51
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit48
Lelse48:
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 3
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 3]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
Lexit48:
leave
ret
Lcont47:
leave
ret
Lcont46:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword [fvar_tbl+160],rax
mov rax,SOB_VOID_ADDRESS
leave
ret
Lcont43:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode49)
jmp Lcont49
Lcode49:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 3
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode50)
jmp Lcont50
Lcode50:
FIX_STACK_LAMBDA_OPT 2
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+1)]
push rax
MAKE_EXT_ENV 4
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode51)
jmp Lcont51
Lcode51:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont51:
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 4]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax,const_tbl+2
push rax
MAKE_EXT_ENV 4
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode52)
jmp Lcont52
Lcode52:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
cmp rax, SOB_FALSE_ADDRESS
je Lelse53
mov rax, qword[rbp + 8*(4+1)]
jmp Lexit53
Lelse53:
mov rax,const_tbl+4
Lexit53:
leave
ret
Lcont52:
push rax
push 3
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 6
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont50:
leave
ret
Lcont49:
push rax
push 1
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode54)
jmp Lcont54
Lcode54:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 8]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
mov rax, qword[rbp + 8*(4+0)]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword [fvar_tbl+192],rax
mov rax,SOB_VOID_ADDRESS
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 9]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
mov rax, qword[rbp + 8*(4+0)]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword [fvar_tbl+200],rax
mov rax,SOB_VOID_ADDRESS
leave
ret
Lcont54:
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont39:
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont32:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+16]
push rax
mov rax, qword[fvar_tbl+144]
push rax
mov rax, qword[fvar_tbl+48]
push rax
push 3
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode55)
jmp Lcont55
Lcode55:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode56)
jmp Lcont56
Lcode56:
FIX_STACK_LAMBDA_OPT 2
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse57
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax,const_tbl+68
push rax
push 2
mov rax, qword[fvar_tbl+152]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax,const_tbl+34
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit57
Lelse57:
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 1]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax,const_tbl+68
push rax
push 2
mov rax, qword[fvar_tbl+152]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
Lexit57:
leave
ret
Lcont56:
leave
ret
Lcont55:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+232], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+56]
push rax
mov rax, qword[fvar_tbl+192]
push rax
mov rax, qword[fvar_tbl+200]
push rax
mov rax, qword[fvar_tbl+136]
push rax
mov rax, qword[fvar_tbl+16]
push rax
push 5
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode58)
jmp Lcont58
Lcode58:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode59)
jmp Lcont59
Lcode59:
FIX_STACK_LAMBDA_OPT 2
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax,const_tbl+2
push rax
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode60)
jmp Lcont60
Lcode60:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
cmp rax, SOB_FALSE_ADDRESS
je Lelse61
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
jne Lexit62
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
jne Lexit62
Lexit62:
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit61
Lelse61:
mov rax,const_tbl+4
Lexit61:
leave
ret
Lcont60:
push rax
push 3
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 4]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 6
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont59:
leave
ret
Lcont58:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+240], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+32]
push rax
mov rax, qword[fvar_tbl+24]
push rax
mov rax, qword[fvar_tbl+16]
push rax
mov rax, qword[fvar_tbl+184]
push rax
push 4
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode63)
jmp Lcont63
Lcode63:
push rbp
mov rbp, rsp
mov rax,const_tbl+23
push rax
push 1
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode64)
jmp Lcont64
Lcode64:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8 * (4 + 0)]
push SOB_NIL_ADDRESS ; something for the cdr
push rax             ; car
push 2               ; argc
push SOB_NIL_ADDRESS ;fake env
call cons
add rsp,8*1          ;pop env
pop rbx              ;pop argc
shl rbx,3            ;rbx=rbx*8
add rsp,rbx          ;pop args
mov qword[rbp + 8 * (4 + 0)],rax
mov qword [rbp + 8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode65)
jmp Lcont65
Lcode65:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse66
mov rax, qword[rbp + 8*(4+0)]
jmp Lexit66
Lelse66:
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
Lexit66:
leave
ret
Lcont65:
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
push SOB_NIL_ADDRESS
call set_car
add rsp, 8              ;pop env
pop rbx                 ;pop argc

shl rbx, 3              ;rbx=rbx*8
add rsp, rbx            ;pop args
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode67)
jmp Lcont67
Lcode67:
FIX_STACK_LAMBDA_OPT 1
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse68
mov rax,const_tbl+34
jmp Lexit68
Lelse68:
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
Lexit68:
leave
ret
Lcont67:
leave
ret
Lcont64:
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont63:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+184], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+192]
push rax
push 1
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode69)
jmp Lcont69
Lcode69:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode70)
jmp Lcont70
Lcode70:
push rbp
mov rbp, rsp
mov rax,const_tbl+34
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont70:
leave
ret
Lcont69:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+248], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+176]
push rax
mov rax, qword[fvar_tbl+192]
push rax
mov rax, qword[fvar_tbl+216]
push rax
push 3
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode71)
jmp Lcont71
Lcode71:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode72)
jmp Lcont72
Lcode72:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse73
mov rax,const_tbl+51
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit73
Lelse73:
mov rax,const_tbl+4
Lexit73:
leave
ret
Lcont72:
leave
ret
Lcont71:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+256], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+216]
push rax
mov rax, qword[fvar_tbl+208]
push rax
push 2
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode74)
jmp Lcont74
Lcode74:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode75)
jmp Lcont75
Lcode75:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
jne Lexit76
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
cmp rax, SOB_FALSE_ADDRESS
jne Lexit76
Lexit76:
leave
ret
Lcont75:
leave
ret
Lcont74:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+264], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+144]
push rax
mov rax, qword[fvar_tbl+56]
push rax
push 2
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode77)
jmp Lcont77
Lcode77:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode78)
jmp Lcont78
Lcode78:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax,const_tbl+34
push rax
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode79)
jmp Lcont79
Lcode79:
push rbp
mov rbp, rsp
mov rax,const_tbl+51
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont79:
push rax
push 3
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 6
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont78:
leave
ret
Lcont77:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+272], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+40]
push rax
mov rax, qword[fvar_tbl+232]
push rax
mov rax, qword[fvar_tbl+200]
push rax
mov rax, qword[fvar_tbl+296]
push rax
mov rax, qword[fvar_tbl+288]
push rax
push 5
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode80)
jmp Lcont80
Lcode80:
push rbp
mov rbp, rsp
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode81)
jmp Lcont81
Lcode81:
push rbp
mov rbp, rsp
mov rax,const_tbl+23
push rax
push 1
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode82)
jmp Lcont82
Lcode82:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8 * (4 + 0)]
push SOB_NIL_ADDRESS ; something for the cdr
push rax             ; car
push 2               ; argc
push SOB_NIL_ADDRESS ;fake env
call cons
add rsp,8*1          ;pop env
pop rbx              ;pop argc
shl rbx,3            ;rbx=rbx*8
add rsp,rbx          ;pop args
mov qword[rbp + 8 * (4 + 0)],rax
mov qword [rbp + 8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
MAKE_EXT_ENV 3
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode83)
jmp Lcont83
Lcode83:
push rbp
mov rbp, rsp
mov rax,const_tbl+34
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse84
mov rax, qword[rbp + 8*(4+1)]
jmp Lexit84
Lelse84:
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 4]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax,const_tbl+51
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 2]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
Lexit84:
leave
ret
Lcont83:
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
push SOB_NIL_ADDRESS
call set_car
add rsp, 8              ;pop env
pop rbx                 ;pop argc

shl rbx, 3              ;rbx=rbx*8
add rsp, rbx            ;pop args
mov rax,const_tbl+1
push rax
mov rax,const_tbl+51
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont82:
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont81:
leave
ret
Lcont80:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+280], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, qword[fvar_tbl+320]
push rax
mov rax, qword[fvar_tbl+32]
push rax
mov rax, qword[fvar_tbl+24]
push rax
mov rax, qword[fvar_tbl+88]
push rax
mov rax, qword[fvar_tbl+312]
push rax
mov rax, qword[fvar_tbl+304]
push rax
mov rax, qword[fvar_tbl+120]
push rax
mov rax, qword[fvar_tbl+208]
push rax
mov rax, qword[fvar_tbl+216]
push rax
mov rax, qword[fvar_tbl+280]
push rax
mov rax, qword[fvar_tbl+192]
push rax
push 11
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode85)
jmp Lcont85
Lcode85:
push rbp
mov rbp, rsp
mov rax,const_tbl+23
push rax
push 1
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode86)
jmp Lcont86
Lcode86:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8 * (4 + 0)]
push SOB_NIL_ADDRESS ; something for the cdr
push rax             ; car
push 2               ; argc
push SOB_NIL_ADDRESS ;fake env
call cons
add rsp,8*1          ;pop env
pop rbx              ;pop argc
shl rbx,3            ;rbx=rbx*8
add rsp,rbx          ;pop args
mov qword[rbp + 8 * (4 + 0)],rax
mov qword [rbp + 8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode87)
jmp Lcont87
Lcode87:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse97
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 2]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
jmp Lexit97
Lelse97:
mov rax,const_tbl+4
Lexit97:
cmp rax, SOB_FALSE_ADDRESS
je Lelse88
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit88
Lelse88:
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse96
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 3]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
jmp Lexit96
Lelse96:
mov rax,const_tbl+4
Lexit96:
cmp rax, SOB_FALSE_ADDRESS
je Lelse89
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit89
Lelse89:
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 5]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse95
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 5]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
jmp Lexit95
Lelse95:
mov rax,const_tbl+4
Lexit95:
cmp rax, SOB_FALSE_ADDRESS
je Lelse90
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 10]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 10]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit90
Lelse90:
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 4]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse94
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 4]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
jmp Lexit94
Lelse94:
mov rax,const_tbl+4
Lexit94:
cmp rax, SOB_FALSE_ADDRESS
je Lelse91
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 8]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 8]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 9]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 9]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit91
Lelse91:
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 6]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
cmp rax, SOB_FALSE_ADDRESS
je Lelse93
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 6]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
jmp Lexit93
Lelse93:
mov rax,const_tbl+4
Lexit93:
cmp rax, SOB_FALSE_ADDRESS
je Lelse92
mov rax, qword[rbp + 8*(4+1)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 1]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit92
Lelse92:
mov rax, qword[rbp + 8*(4+1)]
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 7]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
Lexit92:
Lexit91:
Lexit90:
Lexit89:
Lexit88:
leave
ret
Lcont87:
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
push SOB_NIL_ADDRESS
call set_car
add rsp, 8              ;pop env
pop rbx                 ;pop argc

shl rbx, 3              ;rbx=rbx*8
add rsp, rbx            ;pop args
mov rax, qword[rbp + 8*(4+0)]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
leave
ret
Lcont86:
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont85:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+64], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode98)
jmp Lcont98
Lcode98:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8 * (4 + 0)]
push SOB_NIL_ADDRESS ; something for the cdr
push rax             ; car
push 2               ; argc
push SOB_NIL_ADDRESS ;fake env
call cons
add rsp,8*1          ;pop env
pop rbx              ;pop argc
shl rbx,3            ;rbx=rbx*8
add rsp,rbx          ;pop args
mov qword[rbp + 8 * (4 + 0)],rax
mov qword [rbp + 8*(4+0)], rax
mov rax, SOB_VOID_ADDRESS
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode99)
jmp Lcont99
Lcode99:
push rbp
mov rbp, rsp
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 1                 ;push argc
push SOB_NIL_ADDRESS   ;fake env
call car
add rsp,8*1            ;pop env
pop rbx                ;pop argc
shl rbx,3              ;rbx=rbx*8 
add rsp, rbx           ;pop args
leave
ret
Lcont99:
push rax
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode100)
jmp Lcont100
Lcode100:
push rbp
mov rbp, rsp
mov rax,const_tbl+51
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 2
push SOB_NIL_ADDRESS
call set_car
add rsp, 8              ;pop env
pop rbx                 ;pop argc

shl rbx, 3              ;rbx=rbx*8
add rsp, rbx            ;pop args
mov rax,const_tbl+98
leave
ret
Lcont100:
push rax
push 2
mov rax, qword[fvar_tbl+40]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont98:
mov qword[fvar_tbl+328], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax,const_tbl+107
push rax
push 1
mov rax, qword[fvar_tbl+328]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
mov qword[fvar_tbl+336], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push 0
mov rax, qword[fvar_tbl+336]
push rax
push 1
mov rax, qword[fvar_tbl+32]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
MAKE_EXT_ENV 0
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode101)
jmp Lcont101
Lcode101:
push rbp
mov rbp, rsp
push 0
mov rax, qword[fvar_tbl+336]
push rax
push 1
mov rax, qword[fvar_tbl+24]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
MAKE_EXT_ENV 1
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode102)
jmp Lcont102
Lcode102:
push rbp
mov rbp, rsp
push 0
mov rax, qword[fvar_tbl+336]
push rax
push 1
mov rax, qword[fvar_tbl+32]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
push 1
MAKE_EXT_ENV 2
mov rbx, rax
MAKE_CLOSURE(rax, rbx, Lcode103)
jmp Lcont103
Lcode103:
push rbp
mov rbp, rsp
mov rax,const_tbl+1
push rax
mov rax, qword[rbp + 8*(4+0)]
push rax
push 2
mov rax, qword[fvar_tbl+40]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 0]
mov rax, qword[rax + 8 * 0]
push rax
push 2
mov rax, qword[fvar_tbl+40]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args
push rax
mov rax, qword[rbp + 8*2]
mov rax, qword[rax + 8 * 1]
mov rax, qword[rax + 8 * 0]
push rax
push 2
mov rax, qword[fvar_tbl+40]
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 5
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont103:
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont102:
CLOSURE_ENV rbx, rax
push rbx
push qword[rbp + 8 * 1] ;old ret addr
FIX_STACK_APPLICTP 4
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont101:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp,8*1 ;pop env
pop rbx     ;pop arg count
shl rbx,3   ;rbx = rbx*8
add rsp,rbx ;pop args

	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 ucomisd xmm0, xmm1
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
       .loop:
	 and rdi, rdi
	 jz .end_loop
	 xor rdx, rdx 
	 div rdi
	 mov rax, rdi
	 mov rdi, rdx
	 jmp .loop	
       .end_loop:
	 mov rdx, rax
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret


    cons:
      push rbp
      mov rbp, rsp
      mov rsi, PVAR(0)          ;rsi = car
      mov rdi, PVAR(1)          ;rdi = cdr
      MAKE_PAIR(rax, rsi, rdi)
      pop rbp
      ret
    
    apply:
      push rbp
      mov rbp, rsp
      mov rax, [rbp + 8 * 3]      ; rax = argc
      dec rax
      mov rax, PVAR(rax)          ; rax = last arg = list


      mov rdx, 0                  ; rdx = list_size
      
      push_args:
        cmp byte[rax], T_NIL
        je end_push_args
        CAR rbx, rax              ; rbx = car
        push rbx
        CDR rax, rax              ; rax = cdr
        inc rdx
        jmp push_args
      end_push_args:

      mov rsi,rdx                   ; rsi = list_size backup
      mov rcx, 0                    ; i = 0 
      mov rbx, rdx                  ; rbx = list_size
      shr rbx, 1                    ; rbx = list_size/2
      dec rdx                       ; rdx = list_size -1
      _revert_args:
        cmp rcx, rbx
        jae end_revert_args
        mov rax, [rsp + 8 * (rdx)]          ; rax = [rsp + 8*(list_size - i -1)]
        mov rdi,[rsp+8*rcx]               
        mov [rsp + 8 * rdx], rdi
        mov [rsp + 8 * rcx],  rax
        dec rdx
        inc rcx
        jmp _revert_args
      end_revert_args:

        mov rax, [rbp + 8 * 3]      ;rax = argc
        mov rdi, rax                ;rdi = index
        add rdi,2
        push_objs:
          cmp rdi, 4
          jbe end_push_objs
          push qword [rbp + 8 * rdi]
          inc rsi
          dec rdi
          jmp push_objs
        end_push_objs:
        push rsi                    ;push number of args
        mov rax, PVAR(0)            ; rax = closure of the procedure
        CLOSURE_ENV rbx, rax
        push rbx
        CLOSURE_CODE rbx, rax
        call rbx
        add rsp, 8 * 1
        pop rbx
        shl rbx, 3
        add rsp, rbx
      pop rbp
      ret

    car:
      push rbp
      mov rbp,rsp
      mov rdi,PVAR(0)           ; rdi = pair
      CAR rax,rdi
      pop rbp
      ret
    
      cdr:
        push rbp
        mov rbp, rsp
        mov rdi, PVAR(0)          ;rsi = pair
        CDR rax, rdi
        pop rbp
        ret

      set_car:
        push rbp
        mov rbp, rsp
        mov rdi, PVAR(0)          ;rdi = pair
        mov rsi, PVAR(1)          ;rsi = value
        mov [rdi + TYPE_SIZE], rsi
        pop rbp
        ret

      set_cdr:
        push rbp
        mov rbp, rsp
        mov rdi, PVAR(0)          ;rdi = pair
        mov rsi, PVAR(1)          ;rsi = value
        mov [rdi + WORD_SIZE +TYPE_SIZE], rsi
        pop rbp
        ret
    