diff --git a/code-gen.ml b/code-gen.ml
index dd80017..566f2bb 100644
--- a/code-gen.ml
+++ b/code-gen.ml
@@ -1,39 +1,359 @@
-#use "semantic-analyser.ml";;
-
-(* This module is here for you convenience only!
-   You are not required to use it.
-   you are allowed to change it. *)
-module type CODE_GEN = sig
-  (* This signature assumes the structure of the constants table is
-     a list of key-value pairs:
-     - The keys are constant values (Sexpr(x) or Void)
-     - The values are pairs of:
-       * the offset from the base const_table address in bytes; and
-       * a string containing the byte representation (or a sequence of nasm macros)
-         of the constant value
-     For example: [(Sexpr(Nil), (1, "T_NIL"))]
-   *)
-  val make_consts_tbl : expr' list -> (constant * (int * string)) list
-
-  (* This signature assumes the structure of the fvars table is
-     a list of key-value pairs:
-     - The keys are the fvar names as strings
-     - The values are the offsets from the base fvars_table address in bytes
-     For example: [("boolean?", 0)]
-   *)  
-  val make_fvars_tbl : expr' list -> (string * int) list
-
-  (* If you change the types of the constants and fvars tables, you will have to update
-     this signature to match: The first argument is the constants table type, the second 
-     argument is the fvars table type, and the third is an expr' that has been annotated 
-     by the semantic analyser.
-   *)
-  val generate : (constant * (int * string)) list -> (string * int) list -> expr' -> string
-end;;
-
-module Code_Gen : CODE_GEN = struct
-  let make_consts_tbl asts = raise X_not_yet_implemented;;
-  let make_fvars_tbl asts = raise X_not_yet_implemented;;
-  let generate consts fvars e = raise X_not_yet_implemented;;
-end;;
-
+#use "semantic-analyser.ml";;
+
+(* This module is here for you convenience only!
+   You are not required to use it.
+   you are allowed to change it. *)
+module type CODE_GEN = sig
+  (* This signature assumes the structure of the constants table is
+     a list of key-value pairs:
+     - The keys are constant values (Sexpr(x) or Void)
+     - The values are pairs of:
+       * the offset from the base const_table address in bytes; and
+       * a string containing the byte representation (or a sequence of nasm macros)
+         of the constant value
+     For example: [(Sexpr(Nil), (1, "T_NIL"))]
+   *)
+  val make_consts_tbl : expr' list -> (constant * (int * string)) list
+
+  (* This signature assumes the structure of the fvars table is
+     a list of key-value pairs:
+     - The keys are the fvar names as strings
+     - The values are the offsets from the base fvars_table address in bytes
+     For example: [("boolean?", 0)]
+   *)  
+  val make_fvars_tbl : expr' list -> (string * int) list
+
+  (* If you change the types of the constants and fvars tables, you will have to update
+     this signature to match: The first argument is the constants table type, the second 
+     argument is the fvars table type, and the third is an expr' that has been annotated 
+     by the semantic analyser.
+   *)
+  val generate : (constant * (int * string)) list -> (string * int) list -> expr' -> string
+end;;
+
+let label_counter = ref 0;;
+
+let next ()= 
+  let inc ()= label_counter:= !label_counter + 1 in
+begin inc (); !label_counter end;;
+
+let rec collect_sexp expr =
+  match expr with
+  | Const'(Void) -> []
+  | Const'(Sexpr(x)) -> [x]
+  | If'(test,dit,dif) -> List.append (List.append (collect_sexp test) (collect_sexp dit)) (collect_sexp dif)
+  | LambdaSimple'(params,body) -> collect_sexp body
+  | LambdaOpt'(mandatory, optional, body) -> collect_sexp body
+  | Or'(ors) -> List.fold_left (fun acc o -> List.append acc (collect_sexp o)) [] ors
+  | Set'(vr,vl) -> collect_sexp vl
+  | Seq'(seq) ->  List.fold_left (fun acc e -> List.append acc (collect_sexp e)) [] seq
+  | Def'(vr,vl) -> collect_sexp vl
+  | Applic'(body,args) -> List.append (collect_sexp body) (List.fold_left (fun acc arg -> List.append acc (collect_sexp arg)) [] args)
+  | ApplicTP'(body,args) -> List.append (collect_sexp body) (List.fold_left (fun acc arg -> List.append acc (collect_sexp arg)) [] args)
+  | Var'(x) -> []
+  | BoxSet'(vr,vl) -> collect_sexp vl
+  | BoxGet'(vr) -> []
+  | Box'(var) -> [] ;;
+
+  
+
+  let rec remove_dups lst no_dups= 
+    match lst with
+    | first::rest -> if (List.mem first no_dups) then (remove_dups rest no_dups) else (remove_dups rest (List.append no_dups [first]))
+    | [] -> no_dups;;
+
+
+  let expand_sexpr_list sexpr_list = 
+    let rec expand_sexpr expr = 
+      match expr with
+      | Pair(car,cdr) -> List.append (List.append (expand_sexpr car)(expand_sexpr cdr)) [Sexpr((Pair(car,cdr)))]
+      | Symbol(s) -> Sexpr(String(s))::[Sexpr(Symbol(s))]
+      | sexp -> [Sexpr(sexp)] in
+    List.concat (List.map (fun sexpr -> expand_sexpr sexpr) sexpr_list);;
+    
+    exception X_my_exception of expr;;
+
+    exception X_my_exception1 of expr';;
+
+  let rec find_sexpr_offset sexp const_tbl = 
+    match const_tbl with 
+    | entry::rest -> let (cur_sexpr, (offset, _)) = entry in
+        if (cur_sexpr = sexp) then (string_of_int offset) else find_sexpr_offset sexp rest
+    | [] -> "---------WARNING NO SUCH CONST DEFINED-------------";;
+
+  let rec find_fvar_offset name fvars =
+    match fvars with 
+    |entry::rest -> let (cur_name, offset) = entry in 
+        if(name = cur_name) then string_of_int offset else find_fvar_offset name rest
+    |[] -> "---------WARNING NO SUCH FREE VAR DEFINED -"^name^"------------";;
+
+  let rec build_const_tbl sexprs const_tbl current_offset=
+    let sexpr_to_const_entry sexpr const_tbl current_offset=
+      match sexpr with
+      | Sexpr(Bool(true)) -> (current_offset + 2 ,(Sexpr(Bool(true)), (current_offset , "MAKE_LITERAL_BOOL(1)\n") ))
+      | Sexpr(Bool(false)) -> (current_offset + 2 ,(Sexpr(Bool(false)), (current_offset , "MAKE_LITERAL_BOOL(0)\n") ))
+      | Sexpr(Nil) -> (current_offset + 1 ,(Sexpr(Nil), (current_offset , "MAKE_NIL\n") ) )
+      | Void -> (current_offset + 1 ,(Void, (current_offset , "MAKE_VOID\n") ) ) 
+      | Sexpr(Number(Fraction(num,denum))) -> (current_offset + 17 ,(Sexpr(Number(Fraction(num,denum))), (current_offset , "MAKE_LITERAL_RATIONAL(" ^ (string_of_int num) ^ "," ^ (string_of_int denum) ^ ")\n")))
+      | Sexpr(Number(Float(flt))) -> (current_offset + 9 ,(Sexpr(Number(Float(flt))), (current_offset , "MAKE_LITERAL_FLOAT(" ^ (string_of_float flt) ^ ")\n")))
+      | Sexpr(Char(c)) -> (current_offset + 2 ,(Sexpr(Char(c)), (current_offset, "MAKE_LITERAL_CHAR(" ^ (string_of_int (Char.code c)) ^ ")\n")))
+      | Sexpr(String(str)) -> (current_offset + 9 + (String.length str) ,(Sexpr(String(str)), (current_offset, "MAKE_LITERAL_STRING \"" ^ str ^"\"\n") ) )
+      | Sexpr(Symbol(symb)) -> (current_offset + 9 ,(Sexpr(Symbol(symb)) , (current_offset  , "MAKE_LITERAL_SYMBOL(const_tbl+" ^ (find_sexpr_offset (Sexpr(String(symb))) const_tbl) ^ ")\n")))
+      | Sexpr(Pair(car,cdr)) -> (current_offset + 17, (Sexpr(Pair(car,cdr)) , (current_offset  , "MAKE_LITERAL_PAIR(const_tbl+" ^ (find_sexpr_offset (Sexpr(car)) const_tbl) ^ ",const_tbl+" ^ (find_sexpr_offset (Sexpr(cdr)) const_tbl) ^")\n")))
+      in
+    match sexprs with
+    | sexpr::rest -> let (new_offset, entry) = (sexpr_to_const_entry sexpr const_tbl current_offset) in
+                        build_const_tbl rest (List.append const_tbl [entry]) new_offset
+    | [] -> const_tbl
+
+  let rec collect_fvars expr =
+    match expr with
+    | Const'(Void) -> []
+    | Const'(Sexpr(x)) -> [] 
+    | If'(test,dit,dif) -> List.append (List.append (collect_fvars test) (collect_fvars dit)) (collect_fvars dif)
+    | LambdaSimple'(params,body) -> collect_fvars body
+    | LambdaOpt'(mandatory, optional, body) -> collect_fvars body
+    | Or'(ors) -> List.fold_left (fun acc o -> List.append acc (collect_fvars o)) [] ors
+    | Set'(vr,vl) -> List.append (collect_fvars (Var' (vr))) (collect_fvars vl)
+    | Seq'(seq) ->  List.fold_left (fun acc e -> List.append acc (collect_fvars e)) [] seq
+    | Def'(vr,vl) -> List.append (collect_fvars (Var' (vr))) (collect_fvars vl)
+    | Applic'(body,args) -> List.append (collect_fvars body) (List.fold_left (fun acc arg -> List.append acc (collect_fvars arg)) [] args)
+    | ApplicTP'(body,args) -> List.append (collect_fvars body) (List.fold_left (fun acc arg -> List.append acc (collect_fvars arg)) [] args)
+    | Var'(VarFree(name)) -> [name]
+    | Var'(x) -> []
+    | BoxSet'(vr,vl) -> List.append (collect_fvars (Var'(vr))) (collect_fvars vl)
+    | BoxGet'(vr) -> (collect_fvars (Var'(vr)))
+    | Box'(var) -> (collect_fvars (Var'(var)));;
+
+  let rec build_fvars_tbl fvars index= 
+      match fvars with
+      | first::rest -> (first, index)::(build_fvars_tbl rest (index+8))
+      | [] -> [];;
+
+  
+
+  let rec expr_to_string consts fvars e depth= 
+    match e with 
+    | Def'(VarFree(name), vl) ->  def_to_string consts fvars depth vl name
+    | Const'(c) -> "mov rax,const_tbl+" ^ (find_sexpr_offset c consts) ^ "\n"
+    | Var'(VarParam(_,minor)) -> "mov rax, qword[rbp + 8*(4+" ^ (string_of_int minor) ^ ")]\n"
+    | Set'(VarParam(_, minor), vl) -> (expr_to_string consts fvars vl depth) ^ "mov qword [rbp + 8*(4+" ^ (string_of_int minor) ^ ")], rax\nmov rax, SOB_VOID_ADDRESS\n"
+    | Var'(VarBound(_,major,minor)) -> "mov rax, qword[rbp + 8*2]\nmov rax, qword[rax + 8 * " ^ (string_of_int major) ^ "]\nmov rax, qword[rax + 8 * " ^ (string_of_int minor) ^ "]\n"
+    | Set'(VarBound(_,major,minor), vl) -> (expr_to_string consts fvars vl depth) ^ "mov rbx, qword [rbp + 8 * 2]\nmov rbx, qword [rbx + 8 *"^(string_of_int major)^ "]\nmov qword [rbx + 8 *" ^ (string_of_int minor) ^"], rax\nmov rax, SOB_VOID_ADDRESS\n"
+    | Var'(VarFree(name)) -> "mov rax, qword[fvar_tbl+" ^ (find_fvar_offset name fvars) ^"]\n" 
+    | Set'(VarFree(v),vl) -> (expr_to_string consts fvars vl depth) ^ "mov qword [fvar_tbl+" ^ (find_fvar_offset v fvars) ^ "],rax\nmov rax,SOB_VOID_ADDRESS\n"
+    | Seq'(seq) -> String.concat "" (List.map (fun expr -> expr_to_string consts fvars expr depth) seq) 
+    | Or'(ors) -> or_expr_to_string consts fvars ors depth
+    | If'(test,dit,dif) -> if_expr_to_string consts fvars test dit dif depth
+    | Box'(VarParam(_,minor)) -> box_to_string consts fvars (string_of_int minor) depth
+    | BoxGet'(var) -> box_get_to_string consts fvars var depth
+    | BoxSet'(var,value) -> box_set_to_string consts fvars var depth value 
+    | LambdaSimple'(params,body) ->  lambda_expr_to_string consts fvars params body depth
+    | Applic'(body,args) -> applic_expr_to_string consts fvars body args depth
+    | ApplicTP'(body,args) -> applicTP_expr_to_string consts fvars body args depth
+    | LambdaOpt'(mandatory, optional, body) -> lambda_optional_expr_to_string consts fvars mandatory optional body depth
+    | x -> raise (X_my_exception1 x)
+
+    and def_to_string consts fvars depth vl name =
+      expr_to_string consts fvars vl depth ^ 
+      "mov qword[fvar_tbl+" ^ (find_fvar_offset name fvars) ^"], rax\n" ^
+      "mov rax, SOB_VOID_ADDRESS\n"
+      
+
+
+    and box_to_string consts fvars minor depth =
+      "mov rax, qword[rbp + 8 * (4 + " ^ minor ^ ")]\n" ^
+      "push SOB_NIL_ADDRESS ; something for the cdr\n" ^
+      "push rax             ; car\n" ^
+      "push 2               ; argc\n" ^
+      "push SOB_NIL_ADDRESS ;fake env\n" ^
+      "call cons\n" ^
+      "add rsp,8*1          ;pop env\n" ^
+      "pop rbx              ;pop argc\n" ^
+      "shl rbx,3            ;rbx=rbx*8\n" ^
+      "add rsp,rbx          ;pop args\n" ^
+      "mov qword[rbp + 8 * (4 + " ^ minor ^ ")],rax\n"
+
+    and box_get_to_string consts fvars var depth = 
+     expr_to_string consts fvars (Var'(var)) depth ^
+     "push rax\n"   ^
+     "push 1                 ;push argc\n" ^
+     "push SOB_NIL_ADDRESS   ;fake env\n" ^
+     "call car\n"   ^
+     "add rsp,8*1            ;pop env\n" ^
+     "pop rbx                ;pop argc\n"  ^
+     "shl rbx,3              ;rbx=rbx*8 \n" ^
+     "add rsp, rbx           ;pop args\n" 
+     
+    and box_set_to_string consts fvars var depth value = 
+     expr_to_string consts fvars value depth ^
+     "push rax\n" ^
+     expr_to_string consts fvars (Var'(var)) depth ^
+     "push rax\n" ^
+     "push 2\n" ^
+     "push SOB_NIL_ADDRESS\n" ^
+     "call set_car\n" ^
+     "add rsp, 8              ;pop env\n" ^
+     "pop rbx                 ;pop argc\n\n" ^
+     "shl rbx, 3              ;rbx=rbx*8\n" ^
+     "add rsp, rbx            ;pop args\n" ^
+     "mov rax,SOB_VOID_ADDRESS\n"
+     
+     
+
+    and applic_expr_to_string consts fvars body args depth = 
+      let n = string_of_int (List.length args) in
+      let push_args_code = List.fold_right (fun  arg acc-> acc ^ (expr_to_string consts fvars arg depth) ^ "push rax\n")  args "" in
+      push_args_code ^ 
+      "push " ^ n ^ "\n" ^
+      (expr_to_string consts fvars body depth) ^
+      "CLOSURE_ENV rbx, rax\n" ^
+      "push rbx\n" ^
+      "CLOSURE_CODE rbx, rax\n" ^
+      "call rbx\n" ^
+      "add rsp,8*1 ;pop env\n" ^
+      "pop rbx     ;pop arg count\n" ^
+      "shl rbx,3   ;rbx = rbx*8\n" ^
+      "add rsp,rbx ;pop args\n"
+    
+    and applicTP_expr_to_string consts fvars body args depth =
+      let n = string_of_int (List.length args) in
+      let push_args_code = List.fold_right (fun  arg acc-> acc ^ (expr_to_string consts fvars arg depth) ^ "push rax\n")  args "" in
+      push_args_code ^ 
+      "push " ^ n ^ "\n" ^
+      (expr_to_string consts fvars body depth) ^
+      "CLOSURE_ENV rbx, rax\n" ^
+      "push rbx\n" ^
+      "push qword[rbp + 8 * 1] ;old ret addr\n" ^
+      "FIX_STACK_APPLICTP " ^ (string_of_int (3 + (List.length args))) ^ "\n" ^
+      "CLOSURE_CODE rbx, rax\n" ^
+      "jmp rbx\n" 
+      
+    and lambda_expr_to_string consts fvars params body depth =
+      let num = next () in
+      let lcode = "Lcode" ^ (string_of_int num) in 
+      let lcont = "Lcont" ^ (string_of_int num) in
+      "MAKE_EXT_ENV " ^ (string_of_int depth) ^ 
+      "\nmov rbx, rax\n"^
+      "MAKE_CLOSURE(rax, rbx, "  ^ lcode ^ ")\n"^
+      "jmp " ^ lcont ^ "\n" ^
+      lcode ^ ":\n" ^
+      "push rbp\n" ^
+      "mov rbp, rsp\n" ^
+      expr_to_string consts fvars body (depth + 1) ^
+      "leave\n" ^
+      "ret\n" ^
+      lcont ^ ":\n"
+
+    and lambda_optional_expr_to_string consts fvars mandatory optional body depth =
+    let num = next () in
+    let lcode = "Lcode" ^ (string_of_int num) in 
+    let lcont = "Lcont" ^ (string_of_int num) in
+    let num_of_desired_args = (string_of_int ((List.length mandatory) + 1)) in
+    "MAKE_EXT_ENV " ^ (string_of_int depth) ^ 
+    "\nmov rbx, rax\n"^
+    "MAKE_CLOSURE(rax, rbx, "  ^ lcode ^ ")\n"^
+    "jmp " ^ lcont ^ "\n" ^
+    lcode ^ ":\n" ^ 
+    "FIX_STACK_LAMBDA_OPT " ^ num_of_desired_args ^"\n" ^
+    "push rbp\n" ^
+    "mov rbp, rsp\n" ^
+    expr_to_string consts fvars body (depth + 1) ^
+    "leave\n" ^
+    "ret\n" ^
+    lcont ^ ":\n"
+
+
+
+    and or_expr_to_string consts fvars ors depth= 
+      let ext_label = "Lexit" ^ (string_of_int (next ()))  in
+        (List.fold_left (fun acc o -> acc ^ (expr_to_string consts fvars o depth)  ^"cmp rax, SOB_FALSE_ADDRESS\njne " ^ ext_label ^ "\n" ) "" ors) ^ ext_label ^":\n"
+
+    and if_expr_to_string consts fvars test dit dif depth=
+      let num = next () in
+      let else_label = "Lelse" ^ (string_of_int num) in 
+      let exit_label = "Lexit" ^ (string_of_int num) in
+       (expr_to_string consts fvars test depth) ^ "cmp rax, SOB_FALSE_ADDRESS\nje " ^ else_label ^ "\n" ^
+      (expr_to_string consts fvars dit depth) ^ "jmp " ^ exit_label ^ "\n" ^
+      else_label ^ ":\n" ^
+      (expr_to_string consts fvars dif depth) ^
+      exit_label ^ ":\n"
+    
+
+
+      let primitives =
+        [
+          (* Type queries  *)
+          "boolean?"; "flonum?"; "rational?";
+          "pair?"; "null?"; "char?"; "string?";
+          "procedure?"; "symbol?";
+          (* String procedures *)
+          "string-length"; "string-ref"; "string-set!";
+          "make-string"; "symbol->string";
+          (* Type conversions *)
+          "char->integer"; "integer->char"; "exact->inexact";
+          (* Identity test *)
+          "eq?";
+          (* Arithmetic ops *)
+          "+"; "*"; "/"; "="; "<";
+          (* Additional rational numebr ops *)
+          "numerator"; "denominator"; "gcd";
+          (* you can add yours here *)
+          "apply" ; "car" ; "cdr" ; "cons" ; "set-car!" ; "set-cdr!"
+        ]
+
+
+module Code_Gen : CODE_GEN = struct
+  let make_consts_tbl asts = 
+    let sexprs_list = List.fold_left (fun acc ast -> List.append acc (collect_sexp ast)) [] asts in
+    let sexprs_set = remove_dups sexprs_list [] in
+    let sorted_sexprs_list = expand_sexpr_list sexprs_set  in
+    let sorted_sexprs_list = List.append [Void; Sexpr(Nil) ; Sexpr(Bool(true)) ; Sexpr(Bool(false))] sorted_sexprs_list in
+    let sorted_sexprs_set = remove_dups sorted_sexprs_list [] in 
+    build_const_tbl sorted_sexprs_set [] 0 ;;
+    
+    
+  let make_fvars_tbl asts = 
+    let fvars_list = List.fold_left (fun acc ast -> List.append acc (collect_fvars ast)) [] asts in
+    let fvars_list = List.append fvars_list primitives in
+    let fvars_set = remove_dups fvars_list [] in
+    build_fvars_tbl fvars_set 0;;
+    
+  let generate consts fvars e = expr_to_string consts fvars e 0;;
+end;;
+
+(* let test_collect_sexp str = 
+  collect_sexp (Semantics.run_semantics (List.hd (Tag_Parser.tag_parse_expressions (Reader.read_sexprs str))));;
+
+let test_expand_sexp str =
+  let sexprs_list = List.fold_left (fun acc ast -> List.append acc (collect_sexp ast)) [] (List.map (fun tag_parsed -> Semantics.run_semantics tag_parsed) (Tag_Parser.tag_parse_expressions (Reader.read_sexprs str))) in
+  let sexprs_set = remove_dups sexprs_list [] in
+  let sorted_sexprs_list = expand_sexpr_list sexprs_set  in
+  let sorted_sexprs_set = remove_dups sorted_sexprs_list [] in 
+  sorted_sexprs_set ;;
+
+let test_make_const_table str= 
+  let sexprs_list = List.fold_left (fun acc ast -> List.append acc (collect_sexp ast)) [] (List.map (fun tag_parsed -> Semantics.run_semantics tag_parsed) (Tag_Parser.tag_parse_expressions (Reader.read_sexprs str))) in
+  let sexprs_set = remove_dups sexprs_list [] in
+  let sorted_sexprs_list = expand_sexpr_list sexprs_set  in
+  let sorted_sexprs_list = List.append [ Void; Sexpr(Nil) ; Sexpr(Bool(true)) ; Sexpr(Bool(false))] sorted_sexprs_list in
+  let sorted_sexprs_set = remove_dups sorted_sexprs_list [] in 
+  build_const_tbl sorted_sexprs_set [] 0 ;;
+
+let test_make_fvars_table str = 
+  let fvars_list = List.fold_left (fun acc ast -> List.append acc (collect_fvars ast)) [] (List.map (fun tag_parsed -> Semantics.run_semantics tag_parsed) (Tag_Parser.tag_parse_expressions (Reader.read_sexprs str))) in
+  let fvars_list = List.append fvars_list primitives in
+  let fvars_set = remove_dups fvars_list [] in
+  build_fvars_tbl fvars_set 0;;
+
+
+
+let test_generate_code str= 
+  let consts = test_make_const_table str in
+  let fvars = test_make_fvars_table str in
+  let code = List.fold_left (fun acc ast -> acc ^ (expr_to_string consts fvars ast 0)) "" (List.map Semantics.run_semantics
+                           (Tag_Parser.tag_parse_expressions
+                              (Reader.read_sexprs str))) in
+  Printf.printf "%s" code;; *)
+
+  
\ No newline at end of file
diff --git a/compiler.ml b/compiler.ml
index fbf0ad5..cdc490b 100644
--- a/compiler.ml
+++ b/compiler.ml
@@ -35,6 +35,7 @@ let make_prologue consts_tbl fvars_tbl =
     (* Additional rational numebr ops *)
     "numerator", "numerator"; "denominator", "denominator"; "gcd", "gcd";
     (* you can add yours here *)
+    "cons", "cons"; "apply", "apply"; "car", "car"; "cdr", "cdr"; "set-car!", "set_car"; "set-cdr!", "set_cdr";
   ] in
   let make_primitive_closure (prim, label) =
     (* This implementation assumes fvars are addressed by an offset from the label `fvar_tbl`.
diff --git a/compiler.s b/compiler.s
index fb7d307..feda72c 100644
--- a/compiler.s
+++ b/compiler.s
@@ -138,7 +138,182 @@
 %define MAKE_CLOSURE(r, env, body) \
         MAKE_TWO_WORDS r, T_CLOSURE, env, body
 
+;;--------------------------our code-------------------------------
+; Make a literal of type %1
+;followed by the definition %2
+%macro MAKE_LITERAL 2 
+	db %1			  
+	%2
+%endmacro
+
+%define MAKE_LITERAL_BOOL(val) MAKE_LITERAL T_BOOL,db val  
+
+%define MAKE_NIL db T_NIL
+
+%define MAKE_VOID db T_VOID
+
+%define MAKE_LITERAL_FLOAT(val) MAKE_LITERAL T_FLOAT, dq val
+
+%define MAKE_LITERAL_CHAR(val) MAKE_LITERAL T_CHAR, db val
+
+%macro MAKE_LITERAL_STRING 1
+	db T_STRING
+	dq (%%end_str -%%str)
+	%%str:
+		db %1
+	%%end_str:
+%endmacro
+
+%define MAKE_LITERAL_SYMBOL(str_ptr) MAKE_LITERAL T_SYMBOL,dq str_ptr 
+
+;making an extended envaiorment for a closure
+; %1 = |Env|
+%macro MAKE_EXT_ENV 1
+	
+	MALLOC rax, 8 * (%1 + 1) 					; allocating external Env in size |env| + 1
+	mov rcx,[rbp+8*3]							; rcx = argc
+	shl rcx,3
+	MALLOC rbx, rcx					
+	mov [rax],rbx								; allocate Env[0] with size of argc
+	
+	; for (i = 0 , j = 1 ; i<|Env| ; i++,j++)
+	; 	ExtEnv[j] = Env[i]
+	mov rcx,0									; i = 0
+	mov rbx,1 									; j = 1
+	%%copy_minors:
+		cmp rcx,%1								; if i < |Env|
+		je %%end_copy_minors
+		mov rdx,[rbp + 8 *2]					; rdx = *Env
+		shl rcx,3
+		add rdx,rcx							; rdx = *Env[i]
+		shr rcx,3
+		mov rdx,[rdx]							; rdx = Env[i]
+		mov [rax+8*rbx],rdx 					; ExtEnv[j] = Env[i]
+		inc rcx									; i++
+		inc rbx									; j++
+		jmp %%copy_minors
+	%%end_copy_minors:
 	
+	; for (i= 0 ; i<argc ; i++)
+	; 	ExtEnv[0][i] = Param_i
+	mov rcx,0									; i = 0
+	%%copy_params:
+		cmp rcx,[rbp+8*3]						; if i < argc
+		jae %%end_copy_params
+		mov rdx,[rbp+8*(4+rcx)]					; rdx = param_i
+		mov rbx,[rax]							; rbx = *ExtEnv[0]
+		mov [rbx+(8*rcx)],rdx						; ExtEnv[0][i] = param_i
+		inc rcx									; i++
+		jmp %%copy_params
+	%%end_copy_params:
+
+%endmacro 
+
+
+;adjust stack for lambda optional
+;%1 is the desired # of args
+%macro FIX_STACK_LAMBDA_OPT 1
+	mov rax,%1
+	mov rbx,[rsp+8*2]
+	cmp [rsp+8*2],rax							;if argc >= desired				
+	jb %%missing_arg
+	%%extra_args:
+		mov rcx,[rsp+8*2]
+		sub rcx,%1								; rcx = diff = argc-desired
+		
+		mov rdx, SOB_NIL_ADDRESS
+		; for (int i=0 ; i<=diff ; i++)
+		; 	rdx = Pair(rsp+8*(2+argc-i),rdx)
+		mov rbx,0								; i = 0
+		%%make_pairs:
+			cmp rbx,rcx							; if i <= diff
+			ja %%end_make_pairs
+			mov rdi,[rsp+8*2]					; rdi = argc
+			add rdi,2							; rdi = 2 + argc
+			sub rdi,rbx							; rdi = 2 + argc - i
+			mov rdi, [rsp+8*rdi]				; rdi = [rsp+8*(2+argc-i)]      
+			MAKE_PAIR(rax,rdi,rdx)	
+			mov rdx,rax
+			inc rbx
+			jmp %%make_pairs
+		%%end_make_pairs:
+		mov [rsp+8*(2+%1)],rdx					; last argument = artificial pair
+		
+
+		; for (i = 0 ; i < 4 + desired ; i++)
+		;	[rsp+8*(2+desired-i+diff)]  = [rsp+ 8 *(2+desired-i)]
+		mov rbx,0 								; i = 0
+		%%shift_stack_up:
+			mov rax,4+%1
+			cmp rbx,rax				     		; if i < 4 + desired
+			jae %%end_shift_stack_up
+			mov rdx,2+%1						; rdx = 2 + desired
+			sub rdx,rbx 						; rdx = 2 + desired - i
+			mov rax,[rsp+8*rdx]					; rax = [rsp + 8 * (2+ desired - i)]
+			add rdx,rcx							; rdx = 2 + desired - i + diff
+			mov [rsp+8*rdx],rax					; [rsp+8*(2+desired-i+diff)]  = [rsp+ 8 *(2+desired-i)]
+			inc rbx
+			jmp %%shift_stack_up
+		%%end_shift_stack_up:
+
+		shl rcx,3								; rcx = 8 * rcx
+		add rsp,rcx								; fx stack pointer
+		mov rax,%1
+		mov [rsp+8*2],rax						; fix argc
+		jmp %%end_missing_arg
+	%%missing_arg:
+		;	for (i = 0 ; i < 3 + argc ; i++)	; 3 for Ret,Env,argc
+		;		stack_i = stack_(i+1)
+		mov rbx,0								; i = 0
+		mov rcx,[rsp+8*2]						; rcx = argc
+		add rcx,3								; rcx = argc + 3
+		push SOB_NIL_ADDRESS					; extend the stack with some value
+		%%shift_stack_down:
+			cmp rbx,rcx
+			jae %%end_shift_stack_down
+			mov rax,[rsp+8*(rbx+1)]					; rax = stack_(i+1)
+			mov [rsp+8*rbx],rax					; stack_i = stack_(i+1)
+			inc rbx
+			jmp %%shift_stack_down
+		%%end_shift_stack_down:
+		mov rax,SOB_NIL_ADDRESS
+		mov [rsp+8*(2+%1)],rax					; put () in last argument
+		mov rax,%1
+		mov [rsp+8*2],rax						; fix arg count
+	%%end_missing_arg:
+%endmacro
+
+;fixing the stack when using the tail position optimization
+; %1 = new frame size(h2)
+; old stack frame(h1)
+;------------don't touch rax!! -----------
+%macro FIX_STACK_APPLICTP 1
+	mov rsi,[rbp]								; rsi = old rbp
+	mov rbx, [rbp + 8 * 3]
+	add rbx, 4									; rbx = h1
+	mov rcx, 1									; i = 1
+	%%stack_loop:
+		cmp rcx, %1								;rcx = h2
+		ja %%end_stack_loop
+		mov rdi,rbp								; rdi = rbp
+		shl rcx,3
+		sub rdi,rcx								; rdi = rbp - (8 rcx)
+		shr rcx,3
+		mov rdx, [rdi]
+		mov rdi, rbx
+		sub rdi, rcx
+		mov [rbp + 8 * rdi], rdx
+		inc rcx
+		jmp %%stack_loop
+	%%end_stack_loop:
+	sub rbx, %1
+	shl rbx, 3
+	add rbx,rbp
+	mov rsp,rbx
+	mov rbp,rsi									; rbp = old rbp
+%endmacro
+;;-------------------------------------------------------------------
+		
 ;;; Macros and routines for printing Scheme OBjects to STDOUT
 %define CHAR_NUL 0
 %define CHAR_TAB 9
diff --git a/prims.ml b/prims.ml
index 89ee1ab..6d0780f 100644
--- a/prims.ml
+++ b/prims.ml
@@ -350,8 +350,114 @@ module Prims : PRIMS = struct
       ] in
     String.concat "\n\n" (List.map (fun (a, b, c) -> (b c a)) misc_parts);;
 
+    let basic_ops = "
+    cons:
+      push rbp
+      mov rbp, rsp
+      mov rsi, PVAR(0)          ;rsi = car
+      mov rdi, PVAR(1)          ;rdi = cdr
+      MAKE_PAIR(rax, rsi, rdi)
+      pop rbp
+      ret
+    
+    apply:
+      push rbp
+      mov rbp, rsp
+      mov rax, [rbp + 8 * 3]      ; rax = argc
+      dec rax
+      mov rax, PVAR(rax)          ; rax = last arg = list
+
+
+      mov rdx, 0                  ; rdx = list_size
+      
+      push_args:
+        cmp byte[rax], T_NIL
+        je end_push_args
+        CAR rbx, rax              ; rbx = car
+        push rbx
+        CDR rax, rax              ; rax = cdr
+        inc rdx
+        jmp push_args
+      end_push_args:
+
+      mov rsi,rdx                   ; rsi = list_size backup
+      mov rcx, 0                    ; i = 0 
+      mov rbx, rdx                  ; rbx = list_size
+      shr rbx, 1                    ; rbx = list_size/2
+      dec rdx                       ; rdx = list_size -1
+      _revert_args:
+        cmp rcx, rbx
+        jae end_revert_args
+        mov rax, [rsp + 8 * (rdx)]          ; rax = [rsp + 8*(list_size - i -1)]
+        mov rdi,[rsp+8*rcx]               
+        mov [rsp + 8 * rdx], rdi
+        mov [rsp + 8 * rcx],  rax
+        dec rdx
+        inc rcx
+        jmp _revert_args
+      end_revert_args:
+
+        mov rax, [rbp + 8 * 3]      ;rax = argc
+        mov rdi, rax                ;rdi = index
+        add rdi,2
+        push_objs:
+          cmp rdi, 4
+          jbe end_push_objs
+          push qword [rbp + 8 * rdi]
+          inc rsi
+          dec rdi
+          jmp push_objs
+        end_push_objs:
+        push rsi                    ;push number of args
+        mov rax, PVAR(0)            ; rax = closure of the procedure
+        CLOSURE_ENV rbx, rax
+        push rbx
+        CLOSURE_CODE rbx, rax
+        call rbx
+        add rsp, 8 * 1
+        pop rbx
+        shl rbx, 3
+        add rsp, rbx
+      pop rbp
+      ret
+
+    car:
+      push rbp
+      mov rbp,rsp
+      mov rdi,PVAR(0)           ; rdi = pair
+      CAR rax,rdi
+      pop rbp
+      ret
+    
+      cdr:
+        push rbp
+        mov rbp, rsp
+        mov rdi, PVAR(0)          ;rsi = pair
+        CDR rax, rdi
+        pop rbp
+        ret
+
+      set_car:
+        push rbp
+        mov rbp, rsp
+        mov rdi, PVAR(0)          ;rdi = pair
+        mov rsi, PVAR(1)          ;rsi = value
+        mov [rdi + TYPE_SIZE], rsi
+        pop rbp
+        ret
+
+      set_cdr:
+        push rbp
+        mov rbp, rsp
+        mov rdi, PVAR(0)          ;rdi = pair
+        mov rsi, PVAR(1)          ;rsi = value
+        mov [rdi + WORD_SIZE +TYPE_SIZE], rsi
+        pop rbp
+        ret
+    "
+
   (* This is the interface of the module. It constructs a large x86 64-bit string using the routines
      defined above. The main compiler pipline code (in compiler.ml) calls into this module to get the
      string of primitive procedures. *)
-  let procs = String.concat "\n\n" [type_queries ; numeric_ops; misc_ops];;
+  let procs = String.concat "\n\n" [type_queries ; numeric_ops; misc_ops; basic_ops];;
 end;;
diff --git a/reader.ml b/reader.ml
index 32445c2..689a678 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,46 +1,289 @@
-
-#use "pc.ml";;
-
-exception X_not_yet_implemented;;
-exception X_this_should_not_happen;;
-  
-type number =
-  | Fraction of int * int
-  | Float of float;;
-  
-type sexpr =
-  | Bool of bool
-  | Nil
-  | Number of number
-  | Char of char
-  | String of string
-  | Symbol of string
-  | Pair of sexpr * sexpr;;
-
-let rec sexpr_eq s1 s2 =
-  match s1, s2 with
-  | Bool(b1), Bool(b2) -> b1 = b2
-  | Nil, Nil -> true
-  | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
-  | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
-  | Char(c1), Char(c2) -> c1 = c2
-  | String(s1), String(s2) -> s1 = s2
-  | Symbol(s1), Symbol(s2) -> s1 = s2
-  | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
-  | _ -> false;;
-
-module Reader: sig
-  val read_sexprs : string -> sexpr list
-end
-= struct
-let normalize_scheme_symbol str =
-  let s = string_to_list str in
-  if (andmap
-	(fun ch -> (ch = (lowercase_ascii ch)))
-	s) then str
-  else Printf.sprintf "|%s|" str;;
-
-
-let read_sexprs string = raise X_not_yet_implemented;;
-  
-end;; (* struct Reader *)
+
+#use "pc.ml";;
+open PC;;
+
+  exception X_not_yet_implemented;;
+  exception X_this_should_not_happen;;
+    
+  type number =
+    | Fraction of int * int
+    | Float of float;;
+    
+  type sexpr =
+    | Bool of bool
+    | Nil
+    | Number of number
+    | Char of char
+    | String of string
+    | Symbol of string
+    | Pair of sexpr * sexpr;;
+
+  let rec sexpr_eq s1 s2 =
+    match s1, s2 with
+    | Bool(b1), Bool(b2) -> b1 = b2
+    | Nil, Nil -> true
+    | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
+    | Number(Fraction (n1, d1)), Number(Fraction (n2, d2)) -> n1 = n2 && d1 = d2
+    | Char(c1), Char(c2) -> c1 = c2
+    | String(s1), String(s2) -> s1 = s2
+    | Symbol(s1), Symbol(s2) -> s1 = s2
+    | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
+    | _ -> false;;
+    
+  
+(*-------------------------------------helper functions-------------------------------------*)
+  let rec gcd a b = 
+    if a = 0 then b
+    else gcd (b mod a) a;;
+
+  let float_of_char c = 
+      let num = (int_of_char c)-(int_of_char '0') in
+        float_of_int num;;
+
+  let rec list_to_proper_list = fun(lst) ->
+    match lst with 
+    | car::cdr -> Pair(car, (list_to_proper_list cdr))
+    | x -> Nil;;
+
+  let rec list_to_improper_list = fun (lst) ->
+    match lst with
+    | [] -> Nil
+    | first :: [] -> Pair(first,Nil)
+    | first :: second :: [] -> Pair(first,second)
+    | first :: rest -> Pair(first,list_to_improper_list rest);;
+
+  let make_paired nt_left nt_right nt =
+    let nt = caten nt_left nt in
+    let nt = pack nt (function (_, e) -> e) in
+    let nt = caten nt nt_right in
+    let nt = pack nt (function (e, _) -> e) in
+      nt;;
+
+  let nt_notEndOfLine = guard nt_any (fun(c) -> c != '\n') ;;
+
+  let nt_LineComment = pack 
+                      (caten (char ';') (caten (star nt_notEndOfLine) (maybe (char '\n')))) 
+                      (fun(_,(list_of_char, _)) -> '_');;
+
+  let nt_WhiteSpace = range (char_of_int 0) ' ';;
+(*-------------------------------------Boolean----------------------------------------------*)
+  let nt_False = pack (word_ci "#f") (fun _ -> Bool(false));;
+  let nt_True = pack (word_ci "#t") (fun _ -> Bool(true));;
+  let nt_Boolean = disj nt_False nt_True;;
+
+
+(*-------------------------------------Char-------------------------------------------------*)
+
+  let nt_CharPrefix = word "#\\";; 
+  let nt_VisibleSimpleChar = guard nt_any (fun c -> c > ' ');;
+  let nt_NamedChar = disj_list 
+                      (pack (word_ci "newline") (fun _ -> char_of_int(10)) :: 
+                      pack (word_ci "nul") (fun _-> char_of_int(0)) ::
+                      pack (word_ci "page") (fun _-> char_of_int(12)) ::
+                      pack (word_ci "return") (fun _-> char_of_int(13)) :: 
+                      pack (word_ci "space") (fun _-> char_of_int(32)) ::
+                      pack (word_ci "tab") (fun _->char_of_int(9)) :: []);;
+
+  let nt_Char = pack (caten nt_CharPrefix (disj nt_NamedChar nt_VisibleSimpleChar)) (fun (_,c) -> Char(c));;
+
+(*-------------------------------------Number-----------------------------------------------*)
+  let digit = range '0' '9';;
+
+  let nt_Sign = 
+    let sign =maybe (disj (char '+') (char '-')) in
+    pack sign 
+    (
+      fun (s) ->
+        match s with 
+        | Some('+') -> 1
+        | Some('-') -> -1
+        | None -> 1
+        | _ -> raise X_no_match
+    )
+    ;;
+
+  let nt_Natural = 
+      let digits = plus digit in
+        pack digits (fun (ds) -> (int_of_string (list_to_string ds)));;
+
+  let nt_Mantissa = 
+    let mantissa = plus digit in
+      pack mantissa (
+                    fun (ds) -> 
+                      List.fold_right 
+                          (fun a b ->
+                            let f = (float_of_char a) in
+                            (f +. b ) /. 10.)
+                          ds 
+                          0.
+                  );;
+
+  let nt_IntegerAsInteger =
+    let integ = caten nt_Sign nt_Natural in
+      pack integ 
+      (
+        fun ((sign,num)) -> 
+          sign*num
+      );; 
+      
+
+  let nt_Fraction = 
+    let frac = caten nt_Sign (caten nt_Natural (caten (char '/') nt_Natural)) in
+                pack frac
+                    (fun (sign, (nomer,(_,denom))) ->
+                        let gd = gcd nomer denom in
+                        Number(Fraction(sign * nomer / gd , denom / gd))
+                    )
+                  
+              ;;
+
+  let nt_Snotation = pack (caten (char_ci 'e') nt_IntegerAsInteger) (fun (_,exp)-> 10. ** (float_of_int exp)) ;; 
+
+
+  let nt_Integer = 
+    let integ = caten (caten nt_Sign nt_Natural) (maybe nt_Snotation) in
+    pack integ 
+    (
+      fun (((sign,num),snot)) ->
+        match snot with
+      | Some(snot) ->  Number(Float( (float_of_int (sign*num)) *. snot))
+      | None -> Number(Fraction(sign*num,1))
+    );;
+
+
+  let nt_Float = 
+    let flo = caten (caten (maybe nt_Sign) (caten nt_Natural (caten (char '.') nt_Mantissa))) (maybe nt_Snotation) in
+      pack flo
+      (
+        fun ((sign,(rs,(_,ls))),sn) ->
+        match sign, sn with 
+        |Some(sign), Some(sn) -> Number(Float(sn *. (float_of_int sign) *. ((float_of_int rs) +. ls)))
+        |Some(sign), None -> Number(Float((float_of_int sign) *. ((float_of_int rs) +. ls)))
+        |None, Some(sn) -> Number(Float(sn *. ((float_of_int rs) +. ls)))
+        |None, None -> Number(Float(((float_of_int rs) +. ls)))
+          
+      );;
+              
+  let nt_Number = disj_list(
+  nt_Float :: 
+  nt_Fraction::
+  nt_Integer::[]
+  );;
+
+
+(*-------------------------------------String-----------------------------------------------*)
+    let nt_StringMetaChar = 
+    (disj_list (
+      (pack (word "\\\\") (fun _ -> '\\'))::
+      (pack (word "\\\"") (fun _ -> '\"')) ::
+      (pack (word "\\t") (fun _->'\t'))::
+      (pack (word "\\f") (fun _->'\012'))::
+      (pack (word "\\n") (fun _-> '\n' ))::
+      (pack (word "\\r") (fun _-> '\r'))::[]
+      ));;
+        
+  let nt_StringLiteralChar = guard nt_any (fun(c)-> c != '\"' && c != '\\');;
+
+  let nt_StringChar = disj nt_StringMetaChar nt_StringLiteralChar ;;
+
+  let nt_String = 
+    let str = caten (char '\034') 
+  (caten (star nt_StringChar) (char '\034')) in
+  pack str (fun(_, (char_list, _)) -> String(list_to_string char_list));;
+
+(*-------------------------------------Symbol-----------------------------------------------*)
+
+  let nt_Dot = char '.' ;;
+  let nt_Letter = range_ci 'a' 'z';;
+  let nt_PunctuationMark = disj_list(
+                                char '!' ::
+                                char '$' ::
+                                char '^' ::
+                                char '*' ::
+                                char '-' ::
+                                char '_' ::
+                                char '=' ::
+                                char '+' ::
+                                char '<' ::
+                                char '>' ::
+                                char '?' ::
+                                char '/' ::
+                                char ':' :: []);;
+
+  let nt_SymbolCharNoDot = disj digit (disj nt_Letter nt_PunctuationMark);;
+  let nt_SymbolChar = disj nt_SymbolCharNoDot nt_Dot;;
+  let nt_Symbol = 
+    pack((disj 
+            (pack (caten nt_SymbolChar (plus nt_SymbolChar)) (fun (c,ls) -> c::ls))
+            (pack nt_SymbolCharNoDot (fun c -> c::[]))))
+    (fun (symb) -> Symbol(String.lowercase_ascii (list_to_string symb)));;
+
+(*-------------------------------------Sexp-------------------------------------------------*)
+  let rec nt_Sexpr s= 
+  let nt_sexpr = 
+    make_spacedCommented(disj_list ( 
+                  nt_Boolean::  
+                  nt_Char::       
+                  (not_followed_by nt_Number nt_Symbol)::     
+                  nt_String::     
+                  nt_Symbol::
+                  nt_List s::
+                  nt_DottedList s::
+                  nt_Quoted s::     
+                  nt_QuasiQuoted s::
+                  nt_Unquoted s::   
+                  nt_UnquoteAndSpliced s::[])) 
+  in nt_sexpr s
+
+  (*-------------------------------------comments and whitespace------------------------------*)
+  and nt_SexprComment s= (pack 
+  (caten (word "#;") nt_Sexpr) 
+      (fun(_) -> '_')) 
+
+  and nt_CommentOrWhiteSpaces s=
+    star (disj_list([ nt_WhiteSpace; nt_LineComment; nt_SexprComment s]))
+
+  and make_spacedCommented nt s= make_paired (nt_CommentOrWhiteSpaces s) (nt_CommentOrWhiteSpaces s) nt s
+(*-------------------------------------List-------------------------------------------------*)
+  and nt_List s = 
+  pack (caten (char '(') (caten (nt_CommentOrWhiteSpaces s) (caten (star nt_Sexpr) (char ')')))) 
+  (fun (_, (_, (a, _)))->list_to_proper_list a)
+
+  and nt_DottedList s= 
+  pack
+    (caten (char '(') 
+        (caten (plus nt_Sexpr) 
+          (caten (char '.') 
+          (caten nt_Sexpr (char ')'))))) (fun (_, (ls, (_, (rs, _))))-> list_to_improper_list (List.append ls (rs::[])))
+
+(*-------------------------------------Quotes-----------------------------------------------*)
+
+  and nt_Quoted s= pack (caten (char (char_of_int 39)) nt_Sexpr)
+    (fun (_, (sexp)) -> Pair(Symbol("quote") , Pair(sexp, Nil)))
+
+  and nt_QuasiQuoted s= pack (caten (char '`') nt_Sexpr)
+  (fun (_, (sexp)) -> Pair(Symbol("quasiquote") , Pair(sexp, Nil)))
+
+  and nt_Unquoted s= pack (caten (char ',') nt_Sexpr)
+  (fun (_, (sexp)) -> Pair(Symbol("unquote") , Pair(sexp, Nil)))
+
+  and nt_UnquoteAndSpliced s= pack (caten (word ",@") nt_Sexpr)
+  (fun (_, (sexp)) -> Pair(Symbol("unquote-splicing") , Pair(sexp, Nil)));;
+
+
+module Reader: sig
+  val read_sexprs : string -> sexpr list
+end
+= struct
+let normalize_scheme_symbol str =
+  let s = string_to_list str in
+  if (andmap
+  (fun ch -> (ch = (lowercase_ascii ch)))
+  s) then str
+  else Printf.sprintf "|%s|" str;;
+
+
+let read_sexprs string = 
+            let (lst,rest) = test_string (star nt_Sexpr) string in
+            lst;;
+end;; (* struct Reader *)
diff --git a/readme.txt b/readme.txt
index e69de29..3021a5a 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,10 @@
+Mihael amar - 208383984
+Elad feldman - 308385947
+
+I (We) assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the Internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 8e684f0..6a458cc 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -1,5 +1,7 @@
 #use "tag-parser.ml";;
 
+
+
 type var = 
   | VarFree of string
   | VarParam of string * int
@@ -21,6 +23,9 @@ type expr' =
   | Applic' of expr' * (expr' list)
   | ApplicTP' of expr' * (expr' list);;
 
+
+type env = Env of string list;;
+
 let rec expr'_eq e1 e2 =
   match e1, e2 with
   | Const' Void, Const' Void -> true
@@ -56,10 +61,293 @@ let rec expr'_eq e1 e2 =
   | ApplicTP'(e1, args1), ApplicTP'(e2, args2) ->
 	 (expr'_eq e1 e2) &&
 	   (List.for_all2 expr'_eq args1 args2)
-  | _ -> false;;	
-                      
+  | _ -> false;;
+	
+                       
 exception X_syntax_error;;
 
+(* -------------------------------------helper functions--------------------------------------------- *)
+  let rec index_of_rec lst element indx =
+    match lst with
+    | [] -> -1
+    | car::cdr -> 
+        if (car = element) then indx
+        else index_of_rec cdr element (indx + 1);;
+
+  let index_of lst element = 
+    index_of_rec lst element 0;;
+
+  let rec major_minor_rec lst element env_num= 
+    match lst with
+    | [] -> -1, -1
+    | car::cdr -> let indx = index_of car element in
+      if(indx < 0) then major_minor_rec cdr element (env_num +1)
+      else env_num, indx;;
+
+  let major_minor lst element = 
+    major_minor_rec lst element 0;;
+
+(* -------------------------------------annotate lexical--------------------------------------------- *)
+  let make_var x env=
+    match env with
+    | params::env -> let index = index_of params x in
+                    if(index >= 0) then 
+                      VarParam(x, index)
+                    else 
+                      let major, minor = major_minor env x in
+                      if(major >= 0) 
+                        then VarBound(x, major, minor)
+                      else VarFree(x)
+    | [] -> VarFree(x);;
+
+  let rec annotate_lexical e env =
+    match e with 
+    | Const(c) -> Const'(c)
+    | If(test,dit,dif) -> If'(annotate_lexical test env, annotate_lexical dit env, annotate_lexical dif env)
+    | Seq(seq) -> Seq'(List.map (fun exp-> annotate_lexical exp env) seq)
+    | Set(Var(name),vl) -> Set'(make_var name env , annotate_lexical vl env)
+    | Def(Var(name),vl) -> Def'(make_var name env , annotate_lexical vl env)
+    | Or(ors) -> Or'(List.map (fun exp-> annotate_lexical exp env) ors) 
+    | Applic(func , arguments) -> Applic'(annotate_lexical func env, List.map (fun arg -> annotate_lexical arg env) arguments)
+    | LambdaSimple(params,body) -> LambdaSimple'(params , annotate_lexical body (params::env))
+    | LambdaOpt(mandatory , optional , body) -> LambdaOpt'(mandatory, optional , annotate_lexical body  ((List.append mandatory [optional])::env))
+    | Var(x) -> Var'(make_var x env)
+    | _ -> raise X_syntax_error;;
+
+(* -------------------------------------annotate tail calls------------------------------------------ *)
+  let rec annotate_TC expr in_tp = 
+    match expr with 
+    | Const'(x) -> Const'(x)
+    | Var'(var) -> Var'(var)
+    | If'(test,dit,dif) -> If'(annotate_TC test false, annotate_TC dit in_tp, annotate_TC dif in_tp)
+    | Seq'(seq) -> Seq'(List.mapi (fun index expr -> if (index == ((List.length seq) -1)) then annotate_TC expr in_tp else annotate_TC expr false) seq)
+    | Set'(var,vl) -> Set'(var, annotate_TC vl false)
+    | Def'(var,vl) ->Def'(var, annotate_TC vl false)
+    | Or'(ors) -> Or'(List.mapi (fun index expr -> if (index == ((List.length ors) -1)) then annotate_TC expr in_tp else annotate_TC expr false) ors)
+    | LambdaSimple'(params, body) -> LambdaSimple'(params, annotate_TC body true)
+    | LambdaOpt'(mandatory, optional, body) -> LambdaOpt'(mandatory, optional, annotate_TC body true)
+    | Applic'(body, args) -> 
+      if(in_tp) then 
+        ApplicTP'(annotate_TC body false, List.map (fun arg -> annotate_TC arg false ) args)
+      else 
+        Applic'(annotate_TC body false, List.map (fun arg -> annotate_TC arg false ) args)
+    | _ -> raise X_no_match;;  
+
+(* --------------------------------------Boxing------------------------------------------------------ *)
+  (* ----------------------------------basic boxing------------------------------------------------ *)
+    let ext_env params env = 
+        params::env;;
+    
+    let read_write_append (r_lst1,w_lst1) (r_lst2,w_lst2) =
+        (List.append r_lst1 r_lst2,List.append w_lst1 w_lst2)
+
+    let rec find_read_write exp depth env cur_closure_params= 
+      match exp with
+      | Const'(x) -> ([],[])
+      | If'(test,dit,dif) ->  if_read_write test dit dif depth env cur_closure_params
+      | LambdaSimple'(params,body) -> find_read_write body (depth + 1) (ext_env cur_closure_params env) (Env params)
+      | LambdaOpt'(mandatory, optional, body) -> find_read_write body (depth + 1) (ext_env cur_closure_params env) (Env((List.append mandatory [optional])))
+      | Or'(ors) -> List.fold_left (fun acc exp -> (read_write_append acc (find_read_write exp depth env cur_closure_params)) ) ([],[]) ors
+      | Set'(vr,vl) -> let (reads,writes) = find_read_write vl depth env cur_closure_params in
+                        (reads,List.append (write_var vr depth env cur_closure_params) writes)
+      | Seq'(seq) ->  List.fold_left (fun acc exp -> read_write_append acc (find_read_write exp depth env cur_closure_params)) ([],[]) seq
+      | Def'(vr,vl) -> let (reads,writes) = find_read_write vl depth env cur_closure_params in  
+                        (reads,List.append (write_var vr depth env cur_closure_params) writes )
+      | Applic'(body,args) -> read_write_append (find_read_write body depth env cur_closure_params) (List.fold_left (fun acc exp -> read_write_append acc (find_read_write exp depth env cur_closure_params) ) ([],[]) args)
+      | ApplicTP'(body,args) -> read_write_append (find_read_write body depth env cur_closure_params) (List.fold_left (fun acc exp -> read_write_append acc (find_read_write exp depth env cur_closure_params) ) ([],[]) args)
+      | Var'(VarFree(name)) -> ([],[])
+      | Var'(VarParam(name,minor)) -> if (depth == 0) then ([name, cur_closure_params::env],[]) else ([],[])
+      | Var'(VarBound(name,major,minor)) -> if (depth -1 == major) then ([name, cur_closure_params::env],[]) else ([],[])
+      | BoxSet'(vr,vl) -> find_read_write vl depth env cur_closure_params
+      | BoxGet'(vr) -> ([],[])
+      | Box'(var) -> ([],[])
+
+
+    and if_read_write test dit dif depth env cur_closure_params= 
+      let test_read = find_read_write test depth env cur_closure_params in
+      let dit_read = find_read_write dit depth env cur_closure_params in
+      let dif_read = find_read_write dif depth env cur_closure_params in
+      read_write_append (read_write_append test_read dit_read) dif_read
+
+    and write_var vr depth env params= 
+      match vr with
+      | VarParam(name,minor) -> if (depth == 0) then [name, params::env] else []
+      | VarBound(name,major,minor) -> if (depth - 1 == major) then [name, params::env] else []
+      | VarFree(name) -> [];;
+    
+    let get_read_write params expr  =
+      find_read_write expr 0 [] (Env(params));;
+
+    let get_list (env:env) =
+      let Env(lst) = env in
+      lst;;
+
+    let rec is_common_ancestor (env1:env list) (env2:env list) var = 
+      match env1 with
+      | first::rest -> if ((List.exists (fun x -> x == first) env2) && (not (List.mem var (get_list first)))) then true else is_common_ancestor rest env2 var
+      | [] -> false;; 
+
+    let get_var_name var =
+      match var with
+      | Var'(VarParam(name,_)) -> name
+      | Var'(VarBound(name,_,_)) -> name 
+      | Var'(VarFree(name)) -> name
+      | _ -> raise X_no_match ;;
+
+    let var_match var1 env1 var2 env2 =
+      let rec same_rib (env1:env list) (env2:env list) = 
+        match env1,env2 with
+      | first::rest , [] -> false
+      | [] , first::rest -> false
+      | [] , [] -> true
+      | first1::rest1 , first2::rest2 -> if (first1 == first2) then same_rib rest1 rest2 else false in
+      if ( (var1 = var2) && (not (is_common_ancestor env1 env2 var1)) && (not (same_rib env1 env2))) then true else false 
+  
+  (* ------------------------------additional criteria--------------------------------------------- *)
+    let ignore_to_var_list ignores=
+      let extract_var_from_ignore ignore = 
+        match ignore with 
+        | (VarBound(name,major,minor), _) -> name
+        | _ -> "error" in
+      List.map (fun ignore -> extract_var_from_ignore ignore) ignores;;
+
+    let in_dont_ignore vr dont_ignore_read = 
+      match vr with
+      | VarParam(name,minor) -> List.mem name (ignore_to_var_list dont_ignore_read)
+      | VarBound(name,major,minor) -> List.mem name (ignore_to_var_list dont_ignore_read)
+      | VarFree(name) -> false;;
+
+    let append_to_dont_ignore vr depth dont_ignore env params =
+      match vr with 
+      | VarParam(name,minor) -> dont_ignore
+      | VarBound(name,major,minor) -> if (depth -1 == major) then (VarBound(name,major,minor),params::env)::dont_ignore else dont_ignore
+      | VarFree(name) -> dont_ignore;;
+    
+    let foursome_append (rlist1,wlist1,dir1,diw1) (rlist2,wlist2,dir2,diw2) =
+        let dont_ignore_read  = List.fold_left (fun acc var -> if (not (List.mem var dir1)) then var::acc else acc) dir1 dir2 in
+        let dont_ignore_write  = List.fold_left (fun acc var -> if (not (List.mem var dir1)) then var::acc else acc) diw1 diw2 in
+        (List.append rlist1 rlist2,List.append wlist1 wlist2,dont_ignore_read,dont_ignore_write)
+
+    let rec third_rule_find_read_write exp depth env cur_closure_params dont_ignore_read dont_ignore_write = 
+      match exp with
+      | Const'(x) -> ([],[], dont_ignore_read, dont_ignore_write)
+      | If'(test,dit,dif) ->  third_rule_if_read_write test dit dif depth env cur_closure_params dont_ignore_read dont_ignore_write
+      | LambdaSimple'(params,body) -> third_rule_find_read_write body (depth + 1) (ext_env cur_closure_params env) (Env params) dont_ignore_read dont_ignore_write
+      | LambdaOpt'(mandatory, optional, body) -> third_rule_find_read_write body (depth + 1) (ext_env cur_closure_params env) (Env((List.append mandatory [optional]))) dont_ignore_read dont_ignore_write
+      | Or'(ors) -> List.fold_left (fun acc exp -> (foursome_append acc (third_rule_find_read_write exp depth env cur_closure_params dont_ignore_read dont_ignore_write)) ) ([],[], dont_ignore_read, dont_ignore_write) ors
+      | Set'(vr,vl) -> set_define_find_read_write vr vl depth env cur_closure_params dont_ignore_read dont_ignore_write
+      | Seq'(seq) ->  List.fold_left (fun acc exp -> foursome_append acc (third_rule_find_read_write exp depth env cur_closure_params dont_ignore_read dont_ignore_write)) ([],[], dont_ignore_read, dont_ignore_write) seq
+      | Def'(vr,vl) -> set_define_find_read_write vr vl depth env cur_closure_params dont_ignore_read dont_ignore_write
+      | Applic'(body,args) -> foursome_append (third_rule_find_read_write body depth env cur_closure_params dont_ignore_read dont_ignore_write) (List.fold_left (fun acc exp -> foursome_append acc (third_rule_find_read_write exp depth env cur_closure_params dont_ignore_read dont_ignore_write) ) ([],[],dont_ignore_read,dont_ignore_write) args)
+      | ApplicTP'(body,args) -> foursome_append (third_rule_find_read_write body depth env cur_closure_params dont_ignore_read dont_ignore_write) (List.fold_left (fun acc exp -> foursome_append acc (third_rule_find_read_write exp depth env cur_closure_params dont_ignore_read dont_ignore_write) ) ([],[],dont_ignore_read,dont_ignore_write) args)
+      | Var'(VarFree(name)) -> ([],[], dont_ignore_read, dont_ignore_write)
+      | Var'(VarParam(name,minor)) -> if (depth == 0) && (List.mem name (ignore_to_var_list dont_ignore_write)) then ([name, cur_closure_params::env],[], dont_ignore_read, dont_ignore_write) else ([],[], dont_ignore_read, dont_ignore_write)
+      | Var'(VarBound(name,major,minor)) -> var_bound_find_read_write name major minor env cur_closure_params depth dont_ignore_read dont_ignore_write
+      | BoxSet'(vr,vl) -> third_rule_find_read_write vl depth env cur_closure_params dont_ignore_read dont_ignore_write
+      | BoxGet'(vr) -> ([],[], dont_ignore_read, dont_ignore_write)
+      | Box'(var) -> ([],[], dont_ignore_read, dont_ignore_write)
+
+
+      and var_bound_find_read_write name major minor env cur_closure_params depth dont_ignore_read dont_ignore_write =
+        if (depth -1 == major) && (List.mem name (ignore_to_var_list dont_ignore_write)) then
+                    ([name, cur_closure_params::env],[], (VarBound(name,major,minor), cur_closure_params::env)::dont_ignore_read, dont_ignore_write ) else 
+                    if (depth -1 == major) then
+                    ([],[], (VarBound(name,major,minor), cur_closure_params::env)::dont_ignore_read, dont_ignore_write)
+                    else ([],[], dont_ignore_read, dont_ignore_write)
+
+      and set_define_find_read_write vr vl depth env cur_closure_params dont_ignore_read dont_ignore_write =
+          let (reads,writes, dont_ignore_read1, dont_ignore_write1) = third_rule_find_read_write vl depth env cur_closure_params dont_ignore_read dont_ignore_write in  
+                let writes = if (in_dont_ignore vr dont_ignore_read) 
+                then 
+                List.append (write_var vr depth env cur_closure_params) writes 
+                else 
+                writes in
+                (reads, writes, dont_ignore_read1, (append_to_dont_ignore vr depth dont_ignore_write1 env cur_closure_params))
+
+      and third_rule_if_read_write test dit dif depth env cur_closure_params dont_ignore_read dont_ignore_write= 
+      let test_read = third_rule_find_read_write test depth env cur_closure_params dont_ignore_read dont_ignore_write in
+      let dit_read = third_rule_find_read_write dit depth env cur_closure_params dont_ignore_read dont_ignore_write in
+      let dif_read = third_rule_find_read_write dif depth env cur_closure_params dont_ignore_read dont_ignore_write in
+      foursome_append (foursome_append test_read dit_read) dif_read
+
+    let ignore_to_env ignores =
+      let extract_env ignore =
+        match ignore with 
+        | (VarBound(name,major,minor), env) -> (name, env)
+        | _ -> raise X_no_match in
+      List.map (fun ignore -> extract_env ignore) ignores;;
+
+    let third_rule params body = 
+        let get_dont_ignore_read = (fun (a,b,c,d) -> c) in
+        let get_dont_ignore_write = (fun (a,b,c,d) -> d) in
+        let get_r_w = (fun (a,b,c,d) -> (List.append a (ignore_to_env c), List.append b (ignore_to_env d))) in
+        match body with
+        | Seq'(ribs) ->get_r_w (List.fold_left (fun acc rib -> (foursome_append (third_rule_find_read_write rib 0 [] (Env params) (get_dont_ignore_read acc) (get_dont_ignore_write acc)) acc )) ([],[],[],[])  ribs)
+        | _ -> get_read_write params body;;
+
+  let rec get_need_to_be_boxed_vars params body =
+    if (params = [] ) then [] else 
+    let (reads,writes) = get_read_write params body in
+    let lst = (List.fold_left (fun acc (var1, env1) -> if (List.exists (fun (var2, env2) -> var_match var1 env1 var2 env2) writes) then var1::acc else acc ) [] reads) in
+    List.fold_right (fun param acc  -> if (List.mem param lst) then param::acc else acc) params []
+
+  let rec box_var var_name body =
+    match body with
+    | Const'(x) -> Const'(x)
+    | If'(test,dit,dif) ->  If'(box_var var_name test,box_var var_name dit,box_var var_name dif)
+    | LambdaSimple'(params,body) -> if (List.mem var_name params) then LambdaSimple'(params,body) else LambdaSimple'(params,box_var var_name body)
+    | LambdaOpt'(mandatory, optional, body) -> if (List.mem var_name (List.append mandatory [optional])) then LambdaOpt'(mandatory, optional, body) else LambdaOpt'(mandatory, optional,box_var var_name body)
+    | Or'(ors) -> Or'(List.map (fun expr -> box_var var_name expr) ors)
+    | Set'(vr,Box'(vr2)) -> Set'(vr,Box'(vr2))
+    | Set'(vr,vl) -> if ((get_var_name (Var'(vr))) = var_name) then BoxSet'(vr,box_var var_name vl) else Set'(vr,box_var var_name vl)
+    | Seq'(seq) ->  Seq'(List.map (fun expr -> box_var var_name expr) seq)
+    | Def'(vr,vl) -> Def'(vr,box_var var_name vl)
+    | Applic'(body,args) -> Applic'(box_var var_name body,List.map (fun arg -> box_var var_name arg) args)
+    | ApplicTP'(body,args) -> ApplicTP'(box_var var_name body,List.map (fun arg -> box_var var_name arg) args)
+    | Var'(VarFree(name)) -> Var'(VarFree(name))
+    | Var'(VarParam(name,minor)) -> if (name = var_name) then BoxGet'(VarParam(name,minor)) else Var'(VarParam(name,minor)) 
+    | Var'(VarBound(name,major,minor)) -> if (name = var_name) then BoxGet'(VarBound(name,major,minor)) else Var'(VarBound(name,major,minor))
+    | Box'(vr) -> Box'(vr)
+    | BoxGet'(vr) -> BoxGet'(vr)
+    | BoxSet'(vr,vl) -> BoxSet'(vr,box_var var_name vl) 
+
+  (* add Set'(VarParam(v, minor), Box'(VarParam(v,minor))) in the begging of the lambda *)
+  let add_set_box body vars params=
+    let sets= List.map (fun var_name -> Set'(VarParam(var_name, index_of params var_name),Box'(VarParam(var_name,index_of params var_name)))) vars in
+    match body with 
+    | Seq'(seq) -> Seq'(List.append sets seq)
+    | expr -> Seq'(List.append sets [expr])
+
+  let rec apply_box expr =
+    let (params,body) = match expr with 
+                        | LambdaSimple'(params,body) -> (params,body)
+                        | LambdaOpt'(mandatory, optional, body) -> ((List.append mandatory [optional]),body)
+                        | _ -> raise X_no_match in
+    if (params = []) then expr else
+    let need_to_be_boxed = get_need_to_be_boxed_vars params body in 
+    if (need_to_be_boxed = [] ) then expr else
+    let new_body = add_set_box body need_to_be_boxed params in
+    let new_body = List.fold_left (fun acc var -> box_var var acc) new_body need_to_be_boxed in
+    match expr with 
+    | LambdaSimple'(params,_) -> LambdaSimple'(params,new_body)
+    | LambdaOpt'(mandatory, optional, _) -> LambdaOpt'(mandatory, optional, new_body)
+    | _ -> raise X_no_match
+
+  let rec reach_lambda e =
+    match e with
+    | Const'(x) -> Const'(x)
+    | Var'(var) -> Var'(var)
+    | If'(test,dit,dif) -> If'(reach_lambda test,reach_lambda dit, reach_lambda dif)
+    | Seq'(seq) -> Seq'(List.map reach_lambda seq)
+    | Set'(var,vl) -> Set'(var, reach_lambda vl)
+    | Def'(var,vl) -> Def'(var, reach_lambda vl)
+    | Or'(ors) -> Or'(List.map reach_lambda ors)
+    | LambdaSimple'(params, body) -> apply_box (LambdaSimple'(params,reach_lambda body))
+    | LambdaOpt'(mandatory, optional, body) -> apply_box (LambdaOpt'(mandatory, optional,reach_lambda body))
+    | Applic'(body, args) -> Applic'(reach_lambda body, List.map reach_lambda args)
+    | ApplicTP'(body,args) -> ApplicTP'(reach_lambda body, List.map reach_lambda args)
+    | _ -> raise X_no_match;;  
+
 module type SEMANTICS = sig
   val run_semantics : expr -> expr'
   val annotate_lexical_addresses : expr -> expr'
@@ -67,13 +355,19 @@ module type SEMANTICS = sig
   val box_set : expr' -> expr'
 end;;
 
+
 module Semantics : SEMANTICS = struct
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+let annotate_lexical_addresses e = 
+  annotate_lexical e [];;
+
+
+let annotate_tail_calls e = annotate_TC e false;;
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
 
-let box_set e = raise X_not_yet_implemented;;
+
+let box_set e =  reach_lambda e;; 
+
 
 let run_semantics expr =
   box_set
@@ -82,4 +376,24 @@ let run_semantics expr =
   
 end;; (* struct Semantics *)
 
+let test_tp_string x = 
+  annotate_TC (annotate_lexical (List.hd ((Tag_Parser.tag_parse_expressions (read_sexprs x)))) []) false;;
+
+(* 
+let test_semantics str = Semantics.run_semantics (List.hd (Tag_Parser.tag_parse_expressions (read_sexprs str)));;
+
+let test_find_read_write str =
+  let expr_tag = (annotate_lexical (List.hd ((Tag_Parser.tag_parse_expressions (read_sexprs str)))) []) in
+  let LambdaSimple'(params,body) = expr_tag in
+  find_read_write body 0 [] (Env params);;
+
+
+
+  
+  let test_lexical_string x =
+    annotate_lexical (List.hd ((Tag_Parser.tag_parse_expressions (read_sexprs x)))) [];;
 
+let test_get_need_to_be_boxed_vars str = 
+  let expr_tag = (annotate_lexical (List.hd ((Tag_Parser.tag_parse_expressions (read_sexprs str)))) []) in
+  let LambdaSimple'(params,body) = expr_tag in
+  get_need_to_be_boxed_vars params body;; *)
diff --git a/stdlib.scm b/stdlib.scm
index 2e4a76e..0bdada6 100644
--- a/stdlib.scm
+++ b/stdlib.scm
@@ -19,20 +19,28 @@
       (map-many f args)))))
 
 
-(define fold-left 
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
+(define fold-left (lambda (func acc lst)
+                          (if (null? lst)
+                              acc
+                              (fold-left func (func acc (car lst)) (cdr lst)
+))))
+
 
 (define fold-right
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
+  (lambda (func acc list) 
+	(if (equal? list '()) 
+		acc
+		(func (car list) (fold-right func acc (cdr list)))
+  	))) 
 
 (define cons*
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
+   (lambda (a . b)
+                  (if (eq? b '())
+                      a
+                      (letrec ((f (lambda (x) 
+                                   (if (eq? (cdr x) '())
+                                       (car x)
+                                       (cons (car x) (f (cdr x))))))) (cons a (f b))))))
 
 (define append
   (let ((null? null?)
diff --git a/tag-parser.ml b/tag-parser.ml
index 138249e..69045c5 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -1,21 +1,22 @@
 #use "reader.ml";;
+open Reader;;
 
 type constant =
   | Sexpr of sexpr
   | Void
 
 type expr =
-  | Const of constant
-  | Var of string
-  | If of expr * expr * expr
-  | Seq of expr list
-  | Set of expr * expr
-  | Def of expr * expr
-  | Or of expr list
+  | Const of constant    
+  | Var of string             
+  | If of expr * expr * expr  
+  | Seq of expr list  
+  | Set of expr * expr        
+  | Def of expr * expr         
+  | Or of expr list             
   | LambdaSimple of string list * expr
   | LambdaOpt of string list * string * expr
-  | Applic of expr * (expr list);;
-
+  | Applic of expr * (expr list);;  
+  
 let rec expr_eq e1 e2 =
   match e1, e2 with
   | Const Void, Const Void -> true
@@ -40,8 +41,7 @@ let rec expr_eq e1 e2 =
      (expr_eq e1 e2) &&
        (List.for_all2 expr_eq args1 args2)
   | _ -> false;;
-	
-                       
+	                      
 exception X_syntax_error;;
 
 module type TAG_PARSER = sig
@@ -56,10 +56,242 @@ let reserved_word_list =
    "quasiquote"; "quote"; "set!"; "pset!"; "unquote";
    "unquote-splicing"];;  
 
-(* work on the tag parser starts here *)
+let is_Var x = 
+  not (List.mem x reserved_word_list);;  
+
+let rec is_proper_list pr = 
+  match pr with
+  | Nil -> true
+  | Pair(x, Nil)-> true
+  | Pair(x, Pair(y, z)) -> is_proper_list (Pair(y, z))
+  | Pair (x,y) -> false
+  | _ -> raise X_syntax_error;;
+
+let rec pairs_to_list_map pr func=
+  match pr with
+  | Pair(x,Nil) -> (func x)::[]
+  | Pair(x, Pair(y,z)) -> (func x)::(pairs_to_list_map (Pair(y,z)) func)
+  | Pair(x, y) -> (func x)::[(func y)]
+  | Nil -> []
+  | _ -> raise X_no_match;;
+
+let rec pairs_to_list pr=
+  match pr with
+  | Pair(x,Nil) ->  x::[]
+  | Pair(x, Pair(y,z)) -> x::(pairs_to_list (Pair(y,z)))
+  | Pair(x, y) -> x::[y]
+  | Nil -> []
+  | _ -> raise X_no_match;;
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+let pairs_to_string_list pr =  
+  pairs_to_list_map pr (fun y -> match y with
+                                 | Symbol(x) -> x
+                                 | _ -> raise X_no_match);;
+
+
+let rec seperate_list_last lst = 
+  match lst with
+  |x::y::[] -> x::[] , y
+  |x::y -> let a, b = seperate_list_last y in x::a, b
+  |_ -> raise X_syntax_error
+
+let get_params_vals lst = 
+  let params = pairs_to_list_map lst (fun x ->match x with 
+                                              | (Pair(Symbol(param), _)) -> param
+                                              | _ -> raise  X_syntax_error) in
+  let vals = pairs_to_list_map lst (fun x -> match x with 
+                                             | (Pair(param, Pair(vals, _))) -> vals
+                                             | _ -> raise X_syntax_error ) in
+  (params, vals);;
+  
+let rec list_to_pairs lst = 
+  match lst with 
+  | a::[] -> Pair(a, Nil)
+  | a::b -> Pair(a, list_to_pairs b)
+  | [] -> raise X_syntax_error
+
+let rec tag_parse exp = 
+  match exp with
+  | Number(x) -> Const(Sexpr(Number(x)))
+  | Bool(x) -> Const(Sexpr(Bool(x)))
+  | Char(x) -> Const(Sexpr(Char(x)))
+  | String(x) -> Const(Sexpr(String(x)))
+  | Symbol(x) -> if is_Var(x) then Var(x) else raise X_syntax_error
+  | Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
+  | Pair(Symbol("if"), sexps) -> parse_if sexps 
+  | Pair(Symbol("lambda"), x) -> parse_lambda  x
+  | Pair(Symbol("or"), sexps ) -> parse_or sexps
+  | Pair(Symbol("set!"), Pair(vars, Pair(vals, Nil))) -> Set(tag_parse vars, tag_parse vals)
+  | Pair(Symbol("define"), Pair(Pair(Symbol(name), argl), expr)) -> mit_form_expnder name argl expr
+  | Pair(Symbol("define"), Pair(vars, Pair(vals, Nil))) -> Def(tag_parse vars, tag_parse vals) 
+  | Pair(Symbol("begin"),sexps) -> parse_begin sexps
+  | Pair(Symbol("quasiquote"),Pair(rest, Nil)) -> quasiquote_expander rest 
+  | Pair(Symbol("cond"), rest) -> cond_expander rest  
+  | Pair(Symbol("let"),  Pair(init,body)) -> let_expander init body
+  | Pair(Symbol("let*"), Pair(init,body)) -> let_star_expander init body
+  | Pair(Symbol("letrec"), Pair(init,body)) -> letrec_expander init body
+  | Pair(Symbol("and"), rest) -> and_expander rest
+  | Pair(Symbol("pset!"), rest) -> pset_expander rest
+  | Pair(x, y) -> Applic(tag_parse x, (pairs_to_list_map y tag_parse) )
+  | _ -> raise X_no_match
+
+and parse_if sexps =
+  match sexps with 
+  | Pair(test, Pair(dit, Pair(dif, Nil))) -> If(tag_parse test, tag_parse dit, tag_parse dif)
+  | Pair(test, Pair(dit,Nil)) -> If(tag_parse test, tag_parse dit, Const(Void))
+  | _ -> raise X_no_match
+
+and parse_lambda x = 
+  match x with 
+  | Pair(Symbol(y), body) -> LambdaOpt([], y, parse_seq body)
+  | Pair(args,body) -> if(is_proper_list args) then 
+                          LambdaSimple(pairs_to_string_list args,parse_seq body)
+                      else let args=pairs_to_string_list args in 
+                            let mandatory, optional = seperate_list_last args in
+                          LambdaOpt(mandatory, optional, parse_seq body)
+  | _ -> raise X_syntax_error
+
+and parse_or sexps = 
+  match sexps with
+  | Nil ->  Const(Sexpr(Bool(false)))
+  | Pair(x, Nil) ->  tag_parse x
+  | x -> Or(pairs_to_list_map x tag_parse)
+
+
+and parse_seq exps = 
+  let exps = pairs_to_list exps in
+    if (List.length exps = 1) then  
+      tag_parse (List.hd exps)
+    else 
+      let parsed = List.map tag_parse exps in
+      let parsed = 
+        List.fold_left 
+          (fun acc exp-> 
+            match exp with
+            | Seq(x) -> List.append acc x
+            | _ -> List.append acc [exp] )
+          []
+          parsed in                     
+      Seq(parsed)
+
+and parse_begin sexps = 
+  match sexps with
+  | Nil -> Const(Void)
+  | exps -> parse_seq exps
+   
+and cond_expander sexpr =
+      let rec ribs_expander ribs =
+        match ribs with
+        | [] -> (Pair(Symbol("begin"),Nil))
+        | first::rest ->
+            match first with
+            | Pair(test, Pair(Symbol("=>"), func)) -> apply_cond_rib test func rest
+            | Pair(Symbol("else"), seq) -> (Pair(Symbol("begin"), seq))
+            | Pair(test, seq) ->  (Pair(Symbol("if"), Pair(test, Pair(Pair(Symbol("begin"), seq), Pair(ribs_expander rest,Nil))))) 
+            | _ -> raise X_syntax_error
+  
+      and apply_cond_rib test func rest = 
+        match rest with
+        | [] -> Pair(Symbol "let",Pair(Pair(Pair(Symbol "value", Pair(test, Nil)), Pair(Pair(Symbol "f", Pair(Pair(Symbol "lambda", Pair(Nil, func)), Nil)), Nil)), Pair(Pair(Symbol "if", Pair(Symbol "value", Pair(Pair(Pair(Symbol "f", Nil), Pair(Symbol "value", Nil)), Nil))), Nil)))
+        | _ ->  Pair(Symbol "let",Pair(Pair(Pair(Symbol "value", Pair(test, Nil)), Pair(Pair(Symbol "f", Pair(Pair(Symbol "lambda", Pair(Nil, func)), Nil)), Pair(Pair(Symbol "rest", Pair(Pair(Symbol "lambda", Pair(Nil, Pair(ribs_expander rest, Nil))), Nil)), Nil))), Pair(Pair(Symbol "if", Pair(Symbol "value", Pair(Pair(Pair(Symbol "f", Nil), Pair(Symbol "value", Nil)), Pair(Pair(Symbol "rest", Nil), Nil)))), Nil)))
+  in
+  let ribss = pairs_to_list sexpr in
+  tag_parse (ribs_expander ribss)
+    
+and quasiquote_expander exps = 
+  match exps with
+  | Pair(Symbol("unquote"),Pair(sexpr,Nil)) -> tag_parse sexpr
+  | Pair(Symbol("unquote-splicing"),Pair(sexpr,Nil)) ->tag_parse (Pair(Symbol("quote"),Pair(Pair(Symbol("unquote-splicing"),Pair(sexpr,Nil)),Nil)))
+  | Nil -> tag_parse (Pair(Symbol("quote"),Pair(Nil,Nil)))
+  | Symbol(x) -> tag_parse (Pair(Symbol("quote"),Pair(Symbol(x),Nil)))
+  | Pair(Pair(Symbol("unquote-splicing"),Pair(sexpr,Nil)),b) -> Applic(Var("append"),[tag_parse sexpr ; quasiquote_expander b] )
+  | Pair(a,b) -> Applic(Var("cons"),[quasiquote_expander a ;quasiquote_expander b ])
+  | x -> tag_parse (Pair(Symbol("quote"),Pair(x, Nil)))
+
+
+
+
+
+
+
+
+  (* | Pair(Symbol("unquote"), Pair(sexp, Nil)) -> tag_parse sexp
+  | Pair(Symbol("unquote-splicing"),Pair(sexp, Nil) ) -> raise X_syntax_error
+  | Nil -> tag_parse (Pair(Symbol("quote") , Pair(Nil,Nil)))
+  | Symbol(x) -> tag_parse (Pair(Symbol("quote") , Pair(Symbol(x),Nil) ))
+  | Pair(Pair(Symbol("unquote-splicing"),Pair(sexp, Nil)),b) -> Applic(Var("append"), [tag_parse sexp ;quasiquote_expander b ] )
+  | Pair(a,Pair(Symbol("unquote-splicing"),Pair(sexp, Nil))) -> Applic(Var("cons") , [quasiquote_expander a ; tag_parse sexp])
+  | Pair(a,b) -> Applic(Var("cons") , [quasiquote_expander a; quasiquote_expander b])
+  | _ -> raise X_syntax_error *)
+
+and let_expander init body = 
+  let (paramters,vals) = get_params_vals init in
+  let body = parse_seq body in
+  let func = LambdaSimple(paramters,body) in
+  Applic(func ,List.map tag_parse vals)
+
+and let_star_expander init body =
+  match init with 
+  | Nil -> tag_parse (Pair(Symbol("let"), Pair(Nil, body)))
+  | Pair(x, Pair(y, z)) -> tag_parse (Pair(Symbol("let"), Pair(Pair(x, Nil),Pair(Pair(Symbol("let*"), Pair(Pair(y, z), body)), Nil))))
+  | Pair(x, y) -> tag_parse (Pair(Symbol("let"), Pair(init, body)))
+  | _ -> raise X_syntax_error
+
+and letrec_expander init body =
+  let rec list_to_let_rec_pairs lst =
+    match lst with
+    | [] -> Nil
+    | a::b -> Pair(Pair(a, Pair(Pair(Symbol("quote"),Pair(Symbol("whatever"), Nil)), Nil)), list_to_let_rec_pairs b) in
+  
+  let rec lists_to_let_rec_sets params vals body=
+    match params, vals with
+    | [], [] -> body
+    | a::b, c::d ->  Pair(Pair(Symbol("set!"), Pair(a, Pair(c, Nil))), lists_to_let_rec_sets b d body) 
+    | a::b, [] -> raise X_syntax_error
+    | [], a::b -> raise X_syntax_error in
+  
+  let (params,vals) = get_params_vals init in
+  let params = List.map (fun (x) -> Symbol(x)) params in
+  tag_parse (Pair(Symbol("let") ,Pair(list_to_let_rec_pairs params ,lists_to_let_rec_sets params vals body)))
+
+and and_expander rest = 
+  match rest with 
+  | Nil -> Const(Sexpr(Bool(true)))
+  | Pair(x, Nil) -> tag_parse x
+  | Pair(test,rest) -> 
+    let _then = Pair(Symbol("and") , rest) in
+    let _else = Bool(false) in
+    tag_parse (Pair(Symbol("if"),Pair(test,Pair(_then,Pair(_else,Nil)))))
+  | _ -> raise X_syntax_error
+
+          
+and mit_form_expnder name argl expr =
+  tag_parse (Pair(Symbol("define"), Pair(Symbol(name), Pair(Pair(Symbol("lambda"), Pair(argl, expr)), Nil))))
+
+and pset_expander rest = 
+    let rec init_ribs params vals index =
+      match params,vals with
+      | param::[] , vl::[] -> Pair(Symbol(";" ^ (string_of_int index)), Pair(vl, Nil))::[]
+      | param::rest_params , vl::rest_vals -> Pair(Symbol (";" ^ (string_of_int index)), Pair(vl, Nil))::(init_ribs rest_params rest_vals (index+1))
+      | _ -> raise X_syntax_error in
+    
+    let rec body_expr params index = 
+      match params with 
+      | param::[] -> Pair(Symbol "set!", Pair(Symbol(param), Pair(Symbol (";"^(string_of_int index)), Nil)))::[]
+      | param::rest_params -> Pair(Symbol "set!", Pair(Symbol(param), Pair(Symbol (";"^(string_of_int index)), Nil))) :: (body_expr rest_params (index+1))
+      | _ -> raise X_syntax_error in
+
+    let params, vals = get_params_vals rest in
+    let init = init_ribs params vals 1 in 
+    let body_expressions = body_expr params 1 in
+    let init = list_to_pairs init in
+    let body_expressions = list_to_pairs body_expressions in
+    tag_parse (Pair(Symbol("let"), Pair(init, body_expressions )));;
+
+
+let tag_parse_expressions sexpr = List.map tag_parse sexpr
 
   
 end;; (* struct Tag_Parser *)
 
+
